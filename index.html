<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>graphydb API documentation</title>
<meta name="description" content="Overview â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>graphydb</code></h1>
</header>
<section id="section-intro">
<h1 id="overview">Overview</h1>
<p>GraphyDB is a graph database for Python 3 built ontop of SQLite.</p>
<p>There are many cases where a graph structure is a better fit to a problem domain than a set of tables.
GraphyDB was designed to fill a niche where a flexible embedded graph database was needed
for a moderate sized problem (~10,000 edges and nodes). GraphyDB is not designed to handle terrabytes
of data, and has not been particularly optimised for speed.</p>
<h1 id="quick-start">Quick start</h1>
<p>For example. let's instantiate a graph in memory and add some nodes then connect them, saving them immediately.</p>
<pre><code>from graphydb import Graph

g = Graph()

anne = g.Node('Person', name="Anne").save()
bob = g.Node('Person', name="Bob", nickname='Bobby').save()
charlie = g.Node('Person', name="Charlie").save()

coffee = g.Node('Drink', sort="Coffee").save()
tea = g.Node('Drink', sort="Tea").save()

g.Edge(anne, 'Likes', bob).save()
g.Edge(charlie, 'Likes', bob).save()

g.Edge(anne, 'Drinks', coffee, strength='weak').save()
g.Edge(charlie, 'Drinks', coffee, strength='weak').save()
</code></pre>
<p>Now we can find who drinks coffee. If we have the node we can fetch the incoming references</p>
<pre><code>p1=coffee.inN('e.kind = "Drinks"')

&gt; {[(Y7YQHVNCVUZ9AHH2YH3UVIH86:Person), (3ZKZI0PQAF3CNMEQ7WLUVTW6F:Person)]}
</code></pre>
<p>Or we can query the database directly (and build more sophisticated queries)</p>
<pre><code>p2=g.fetch('[p:Person,strength] -(e:Drinks)&gt; (d:Drink)', 'd.data.sort = "Coffee"', strength='e.data.strength')

&gt; {[(Y7YQHVNCVUZ9AHH2YH3UVIH86:Person), (3ZKZI0PQAF3CNMEQ7WLUVTW6F:Person)]}

p2[0].data

&gt; {'_strength': 'weak',
  'ctime': 1474270482.224738,
  'kind': 'Person',
  'mtime': 1474270482.224739,
  'name': 'Anne',
  'uid': 'Y7YQHVNCVUZ9AHH2YH3UVIH86'}
</code></pre>
<h1 id="sqlite-structure">SQLite structure</h1>
<p>Two tables hold most of the data, one for nodes and one for edges.
Additional tables provide a key-value stores for preferences and a cache. FTS indices are
also held in the database.</p>
<h2 id="nodes">Nodes</h2>
<p>Nodes are held in the table <code>nodes</code> with the columns</p>
<ul>
<li><code>uid</code> [TEXT PRIMARY KEY] A 25 character UUID assumed to be unique across all items past and future</li>
<li><code>kind</code> [TEXT] The node kind, e.g. "Person", "Document" etc</li>
<li><code>ctime</code> [REAL] Item creation time in seconds since the epoch as a floating point number</li>
<li><code>mtime</code> [REAL] Item last modification time in seconds since the epoch as a floating point number</li>
<li><code>data</code> [TEXT] A JSON encoded distionary of keys and values</li>
</ul>
<h2 id="edges">Edges</h2>
<p>Edges are held in the table <code>edges</code> with the columns</p>
<ul>
<li><code>uid</code> [TEXT PRIMARY KEY] A 25 character UUID assumed to be unique across all items past and future</li>
<li><code>kind</code> [TEXT] The edge kind e.g. "Likes", "Authored" etc</li>
<li><code>startuid</code> [TEXT NOT NULL REFERENCES nodes(uid)]</li>
<li><code>enduid</code> [TEXT NOT NULL REFERENCES nodes(uid)]</li>
<li><code>ctime</code> [REAL] Item creation time in seconds since the epoch as a floating point number</li>
<li><code>mtime</code> [REAL] Item last modification time in seconds since the epoch as a floating point number</li>
<li><code>data</code> [TEXT] A JSON encoded distionary of keys and values</li>
</ul>
<p>Note that any two nodes can be connected by multiple edges so the structure is not a simple graph but
a directed multigraph with the possibility of loops.
This makes it possible to have metadata associated with each edge kind. It's up to the application to
deal with multiple edges.</p>
<h2 id="additional-tables">Additional tables</h2>
<p>Two additional tables <code>settings</code> and <code>cache</code> provide simple key-value stores with the columns</p>
<ul>
<li><code>key</code> [TEXT PRIMARY KEY] Some unique string for the key</li>
<li><code>value</code> [TEXT] JSON encoded data for the value</li>
</ul>
<h1 id="installing">Installing</h1>
<h2 id="dependencies">Dependencies</h2>
<ol>
<li>apsw (with fts5 and json1 extensions)</li>
</ol>
<h1 id="module-details">Module details</h1>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
#
# GraphyDB
#
# A python graph database implemented on top of SQLite.
#
# Alexei Gilchrist
# Copyright 2016
# 
# (Python 3 required)
#  
#
&#39;&#39;&#39;
# Overview

GraphyDB is a graph database for Python 3 built ontop of SQLite.

There are many cases where a graph structure is a better fit to a problem domain than a set of tables.
GraphyDB was designed to fill a niche where a flexible embedded graph database was needed
for a moderate sized problem (~10,000 edges and nodes). GraphyDB is not designed to handle terrabytes
of data, and has not been particularly optimised for speed.


# Quick start

For example. let&#39;s instantiate a graph in memory and add some nodes then connect them, saving them immediately.

    from graphydb import Graph

    g = Graph()
    
    anne = g.Node(&#39;Person&#39;, name=&#34;Anne&#34;).save()
    bob = g.Node(&#39;Person&#39;, name=&#34;Bob&#34;, nickname=&#39;Bobby&#39;).save()
    charlie = g.Node(&#39;Person&#39;, name=&#34;Charlie&#34;).save()
    
    coffee = g.Node(&#39;Drink&#39;, sort=&#34;Coffee&#34;).save()
    tea = g.Node(&#39;Drink&#39;, sort=&#34;Tea&#34;).save()
    
    g.Edge(anne, &#39;Likes&#39;, bob).save()
    g.Edge(charlie, &#39;Likes&#39;, bob).save()
    
    g.Edge(anne, &#39;Drinks&#39;, coffee, strength=&#39;weak&#39;).save()
    g.Edge(charlie, &#39;Drinks&#39;, coffee, strength=&#39;weak&#39;).save()

Now we can find who drinks coffee. If we have the node we can fetch the incoming references

    p1=coffee.inN(&#39;e.kind = &#34;Drinks&#34;&#39;)
    
    &gt; {[(Y7YQHVNCVUZ9AHH2YH3UVIH86:Person), (3ZKZI0PQAF3CNMEQ7WLUVTW6F:Person)]}
    
Or we can query the database directly (and build more sophisticated queries)

    p2=g.fetch(&#39;[p:Person,strength] -(e:Drinks)&gt; (d:Drink)&#39;, &#39;d.data.sort = &#34;Coffee&#34;&#39;, strength=&#39;e.data.strength&#39;)
    
    &gt; {[(Y7YQHVNCVUZ9AHH2YH3UVIH86:Person), (3ZKZI0PQAF3CNMEQ7WLUVTW6F:Person)]}
    
    p2[0].data
    
    &gt; {&#39;_strength&#39;: &#39;weak&#39;,
      &#39;ctime&#39;: 1474270482.224738,
      &#39;kind&#39;: &#39;Person&#39;,
      &#39;mtime&#39;: 1474270482.224739,
      &#39;name&#39;: &#39;Anne&#39;,
      &#39;uid&#39;: &#39;Y7YQHVNCVUZ9AHH2YH3UVIH86&#39;}
    

# SQLite structure    

Two tables hold most of the data, one for nodes and one for edges. 
Additional tables provide a key-value stores for preferences and a cache. FTS indices are
also held in the database.


## Nodes

Nodes are held in the table `nodes` with the columns

- `uid` [TEXT PRIMARY KEY] A 25 character UUID assumed to be unique across all items past and future
- `kind` [TEXT] The node kind, e.g. &#34;Person&#34;, &#34;Document&#34; etc
- `ctime` [REAL] Item creation time in seconds since the epoch as a floating point number
- `mtime` [REAL] Item last modification time in seconds since the epoch as a floating point number
- `data` [TEXT] A JSON encoded distionary of keys and values

## Edges

Edges are held in the table `edges` with the columns

- `uid` [TEXT PRIMARY KEY] A 25 character UUID assumed to be unique across all items past and future
- `kind` [TEXT] The edge kind e.g. &#34;Likes&#34;, &#34;Authored&#34; etc
- `startuid` [TEXT NOT NULL REFERENCES nodes(uid)]
- `enduid` [TEXT NOT NULL REFERENCES nodes(uid)]
- `ctime` [REAL] Item creation time in seconds since the epoch as a floating point number
- `mtime` [REAL] Item last modification time in seconds since the epoch as a floating point number
- `data` [TEXT] A JSON encoded distionary of keys and values

Note that any two nodes can be connected by multiple edges so the structure is not a simple graph but
a directed multigraph with the possibility of loops.
This makes it possible to have metadata associated with each edge kind. It&#39;s up to the application to
deal with multiple edges.

## Additional tables

Two additional tables `settings` and `cache` provide simple key-value stores with the columns

- `key` [TEXT PRIMARY KEY] Some unique string for the key
- `value` [TEXT] JSON encoded data for the value

# Installing

## Dependencies

  1. apsw (with fts5 and json1 extensions)
  
  
# Module details
&#39;&#39;&#39;

import json, re, os, random, fnmatch, time, copy
from collections import MutableMapping
import apsw
import logging
from datetime import datetime
import functools, itertools

logging.basicConfig(format=&#39;%(levelname)s:%(message)s&#39;, level=logging.DEBUG)

__version__ = 0.42


RESERVED = [&#39;uid&#39;,&#39;kind&#39;,&#39;ctime&#39;,&#39;mtime&#39;,&#39;startuid&#39;,&#39;enduid&#39;]
&#39;&#39;&#39;Reserved keyword that cannot be used in node and edge data.&#39;&#39;&#39;

FETCHKEYWORDS = [&#39;WHERE&#39;,&#39;CHAIN&#39;,&#39;ORDER&#39;,&#39;LIMIT&#39;,&#39;GROUP&#39;, &#39;COUNT&#39;, &#39;DISTINCT&#39;, &#39;OFFSET&#39;, &#39;DEBUG&#39;]
&#39;&#39;&#39;Keywords used in `graphydb.Graph.fetch`, everything else is a parameter.&#39;&#39;&#39;

#-------------------------------------------------------------------------------- 
def generateUUID():
    &#39;&#39;&#39;
    Generate a random UUID.
    Make as short as possible by encoding in all numbers and letters.
    Sequence has to be case insensitive to support any filesystem and web.
    &#39;&#39;&#39;
    ## the standard uuid is 16 bytes. this has
    ## 256**16 = 340282366920938463463374607431768211456 possible values
    ## In hex with the alphabet &#39;0123456789abcdef&#39; this is
    ## 16**32 = 340282366920938463463374607431768211456
    ## encoding with the alphabet = &#39;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;
    ## can be done in 25 characters:
    ## 36**25 = 808281277464764060643139600456536293376
    ## keep case insensitive for robustness in URLS etc 
    ## (case sensitivity would only drop it to 22 characters)

    alphabet = &#39;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;
    N = len(alphabet)

    # emulate how uuid4 grabs entropy
    try:
        # first try to use the system urandom module if available
        # this should be more cryptographically secure than random
        rand = random.SystemRandom().random
        uu = &#39;&#39;.join([alphabet[(rand()*N).__int__()] for i in range(25)])
    except:
        # fall back on random
        rand = random.random
        uu = &#39;&#39;.join([alphabet[(rand()*N).__int__()] for i in range(25)])

    return uu

#--------------------------------------------------------------------------------
def jsonextract(param):
    &#39;&#39;&#39;
    Helper function to wrap json extractions.
       
        e.g. `x.data.y` becomes `json_extract(x.data, &#34;$.y&#34;)`

    &#39;&#39;&#39;
    return re.sub(&#39;(\w+)\.data\.(\w+)&#39;,r&#39;json_extract(\1.data, &#34;$.\2&#34;)&#39;, param)

def ensurelist(x):
    &#39;&#39;&#39;
    Helper function to ensure argument is a list.
    &#39;&#39;&#39;
    if x is None:
        x = []
    elif type(x) != type([]):
        x = [x]
    return x

def conditionalyield(keys,A,B):
    &#39;&#39;&#39;
    Iterator over values A[k] | B[k]
    &#39;&#39;&#39;
    for k in keys:
        yield (A[k] if k in A else B[k])
        
def cleandata(fulldata):
    &#39;&#39;&#39;
    Return dict without keys that start with underscore (which are treated as temporary local variables).
    &#39;&#39;&#39;
    data = {k:v for k,v in fulldata.items() if k[0] != &#39;_&#39;}    
    return data

def diff(d1,d2,changedkeys):
    &#39;&#39;&#39;
    Calculate a simple diff that takes dict d1 to d2.
    Only keys in the set changedkeys are considered.
    Keys starting with underscore are ignored.
    &#39;&#39;&#39;
    remove = {}
    add = {}
    
    for k in d1.keys()|d2.keys():
        if k[0] == &#39;_&#39;:
            continue
        elif k in changedkeys:
            ## only consider keys explicitly marked as changed
            if k not in d2:
                remove[k] = d1[k]
            elif k not in d1:
                add[k] = d2[k]
            elif d1[k]!=d2[k]:
                ## only stored if values are actually different
                remove[k] = d1[k]
                add[k] = d2[k]
            
    if len(remove) == 1 and &#39;mtime&#39; in remove and len(add) == 1 and &#39;mtime&#39; in add:
        remove = {}
        add = {}
        
    change = {}
    if len(add)&gt;0:
        change[&#39;+&#39;] = add
    if len(remove)&gt;0:
        change[&#39;-&#39;] = remove
        
    return change

def patch(d, change, reverse=False):
    &#39;&#39;&#39;
    Patch a dict based on a change dict.
    Return a patched shallow copy.
    &#39;&#39;&#39;
    d2=dict(d)
    if reverse:
        for k in change.get(&#39;+&#39;,{}).keys():
            del d2[k]
        d2.update(change.get(&#39;-&#39;,{}))
    else:
        for k in change.get(&#39;-&#39;,{}).keys():
            del d2[k]
        d2.update(change.get(&#39;+&#39;,{}))
    return d2
#-------------------------------------------------------------------------------- 
class GraphyDBException(Exception):
    &#39;&#39;&#39;
    Any exceptions thrown by `graphydb`.
    &#39;&#39;&#39;
    pass

#--------------------------------------------------------------------------------
class IndexedSet:
    &#39;&#39;&#39;
    Implements an indexed and sorted set.
    
    The collection supports a subset of list, set, and dict operations. 
    
    The objects in the collection must expose a `__uid__()` method that returns a unique string uid 
    for the object. This uid is what will be used to index the object and in set comparisons.
    
    Items are maintained in order and are indexed so can be looked up by uid. Internally, the data is 
    stored in a dict `_index` *and* list `_list`, but these shouldn&#39;t be modified directly as
    they need to be kept in sync.
    
    Speed of set operations are about 10x slower than native sets but with a much faster
    creation time for populating the collection. Since set operations are already really fast, 
    the collection has been optimised to reduce the creation time to have overall performance.
    &#39;&#39;&#39;
        
    def __init__(self, iterable=[]):
        &#39;&#39;&#39;
        Takes an interable of objects with a `__uid__()` method. 
        &#39;&#39;&#39;
        self._index = {n.__uid__():n for n in iterable}
        self._list = list(iterable)
        if len(self._list) != len(self._index.keys()):
            ## iterable contains duplicates. Base the list on the _index.
            self._list = list(self._index.values())

    def copy(self):
        &#39;&#39;&#39;
        Return a shallow copy. 
        
        This means any mutable objects inside the 
        collected object with be references to the original.
        &#39;&#39;&#39;
        ## N.B. in __init__ a shallow copy is made anyway  
        ## but it&#39;s faster to copy the parsed structures
        new = self.__class__()
        new._index = self._index.copy()
        new._list = self._list.copy()
        return new

    #
    # list methods
    #
    
    def sort(self, key=None, reverse=False):
        &#39;&#39;&#39;
        Sort items in place. Returns reference.
        &#39;&#39;&#39;
        self._list.sort(key=key, reverse=reverse)
        return self
        
    def __getitem__(self, key):
        if isinstance(key, slice):
            return self.__class__(self._list[key])
        elif isinstance(key, str):
            return self._index[key]
        else:
            return self._list[key]
        
    def __iter__(self):  
        return iter(self._list)
    
    def reverse(self):
        &#39;&#39;&#39;
        Reverse item order in place. Returns reference.
        &#39;&#39;&#39;
        self._list.reverse()
        return self

    def __delitem__(self, i):
        if isinstance(i, slice):
            values = self._list[i]
        else:
            values = [self._list[i]]
        for v in values:
            del self._index[v.__uid__()]
        del self._list[i]
    
    def __repr__(self):
        return &#34;{{{}}}&#34;.format(self._list.__repr__()) 

    def append(self, item):
        &#39;&#39;&#39;
        Append an item to collection, 
        overwriting and moving to end if present (by uid).
        Returns reference.
        &#39;&#39;&#39;
        self.discard(item)
        uid = item.__uid__()
        self._index[uid] = item
        self._list.append(item)  
        return self
    
    #
    # set methods
    #
    
    def clear(self):
        &#39;&#39;&#39;
        Clear all the contents. Returns reference.
        &#39;&#39;&#39;
        self._list = list()
        self._index = dict()
        return self
    
    def add(self, item):
        &#39;&#39;&#39;
        Add an item to collection, 
        overwriting if already present (by uid) and keeping position.
        Returns reference.
        &#39;&#39;&#39;
        uid = item.__uid__()
        if uid in self._index:
            current = self._index[uid]
            self._index[uid] = item
            idx = self._list.index(current)
            self._list[idx] = item
        else:
            self._list.append(item)
            self._index[uid]=item
        return self

    def remove(self, item):
        &#39;&#39;&#39;
        Remove item (with same uid) from the collection.
        Raise KeyError if item not present.
        Returns reference.
        &#39;&#39;&#39;
        uid = item.__uid__()
        ## make sure it is the item in collection with same uid
        actualitem = self._index[uid]
        self._list.remove(actualitem)
        del self._index[uid]
        return self
     
    def discard(self, item):
        &#39;&#39;&#39;
        Remove item (with same uid) from the collection.
        Ignore if item not present.
        Returns reference.
        &#39;&#39;&#39;
        uid = item.__uid__()
        if uid in self._index:
            ## make sure it is the item in collection with same uid
            actualitem = self._index[uid]
            self._list.remove(actualitem)
            del self._index[uid]
        return self
    
    def __lt__(self, other):
        return self._index.keys().__lt__(other._index.keys())
    def __le__(self, other):
        return self._index.keys().__le__(other._index.keys())
    def __eq__(self, other):
        return self._index.keys().__eq__(other._index.keys())
    def __ne__(self, other):
        return self._index.keys().__ne__(other._index.keys())
    def __gt__(self, other):
        return self._index.keys().__gt__(other._index.keys())
    def __ge__(self, other):
        return self._index.keys().__ge__(other._index.keys())
    def __cmp__(self, other):
        return self._index.keys().__cmp__(other._index.keys())

    def union(self, *others):
        return functools.reduce(lambda x,y:x|y,others, self) 
    def intersection(self, *others):
        return functools.reduce(lambda x,y:x&amp;y,others, self)
    def difference(self, *others):
        return functools.reduce(lambda x,y:x-y,others, self)   

    def symmetric_difference(self, other):
        ## N.B. keys() has no symmetric_difference() so convert to full set first
        keys = set(self._index.keys()).symmetric_difference(other._index.keys())
        return self.__class__(conditionalyield(keys,self._index,other._index))

    def __and__(self, other):
        keys = self._index.keys().__and__(other._index.keys())
        return self.__class__(conditionalyield(keys,self._index,other._index))
    def __xor__(self, other):
        keys = self._index.keys().__xor__(other._index.keys())
        return self.__class__(conditionalyield(keys,self._index,other._index))
    def __or__(self, other):
        keys = self._index.keys().__or__(other._index.keys())
        return self.__class__(conditionalyield(keys, self._index, other._index))
    def __sub__(self, other):
        keys = self._index.keys().__sub__(other._index.keys())
        return self.__class__(conditionalyield(keys, self._index, other._index))
            
    #
    # common methods
    #
       
    def __len__(self):
        return self._index.__len__()
    
    def __contains__(self, item):
        &#39;&#39;&#39;
        Based on uid only.
        &#39;&#39;&#39;
        return self._index.__contains__(item)
    
    def pop(self, idx=-1):
        &#39;&#39;&#39;
        Retrieves the item at location `idx` and also removes it. Defaults to end of list.
        &#39;&#39;&#39;
        item = self._list.pop(idx)
        del self._index[item.__uid__()]
        return item
           
    def update(self, *iterables):
        &#39;&#39;&#39;
        Uodate the existing items with the items in `*iterables`.
        Returns reference.
        &#39;&#39;&#39;
        _add = self.add
        for iterable in iterables:
            for value in iterable:
                _add(value)
        return self
    
#-------------------------------------------------------------------------------- 
class Graph:
    &#39;&#39;&#39;
    A graph composed of nodes and edges, both stored in SQLite database.
    &#39;&#39;&#39;
    def __init__(self, path=&#39;:memory:&#39;):
        &#39;&#39;&#39;
        Instantiating it without argument creates an in-memory database, 
        pass in a path to create or open a database in a file
    
            memdb = Graph()
       
            filedb = Graph(path)
        &#39;&#39;&#39;
        self.path = path
        if os.path.exists(path):
            ## connect to existing database
            self.connection = apsw.Connection(self.path)
        else:
            ## create new database and set up tables
            self.connection = apsw.Connection(self.path)
            self.reset() 
            self.resetfts()
        
    def reset(self):
        &#39;&#39;&#39;
        Drop the tables and recreate them.
        *All data will be lost!*
        &#39;&#39;&#39;
        cursor=self.cursor()
                  
        cursor.execute(&#39;&#39;&#39;
            DROP TABLE IF EXISTS nodes;
            DROP TABLE IF EXISTS edges;
            DROP TABLE IF EXISTS settings;
            DROP TABLE IF EXISTS cache;
            DROP TABLE IF EXISTS changes;
            CREATE TABLE IF NOT EXISTS nodes(uid TEXT PRIMARY KEY, kind TEXT, ctime REAL, mtime REAL, data TEXT);
            CREATE TABLE IF NOT EXISTS edges(uid TEXT PRIMARY KEY, kind TEXT, startuid TEXT NOT NULL REFERENCES nodes(uid), enduid TEXT NOT NULL REFERENCES nodes(uid), ctime REAL, mtime REAL, data TEXT);
            CREATE TABLE IF NOT EXISTS settings(key TEXT PRIMARY KEY, value TEXT);
            CREATE TABLE IF NOT EXISTS cache(key TEXT PRIMARY KEY, value TEXT);
            CREATE TABLE IF NOT EXISTS changes(id INTEGER PRIMARY KEY AUTOINCREMENT, change TEXT);
        &#39;&#39;&#39;)
        
        ## store GraphyDB version that was used to create the database
        self.savesetting(&#39;GraphyDB version&#39;, __version__)

    def countchanges(self):
        cursor=self.cursor()
        n=cursor.execute(&#39;SELECT COUNT(*) FROM changes&#39;).fetchone()[0]
        return n
    
    def clearchanges(self):
        ## recreate table so it resets the IDs
        cursor=self.cursor()
        cursor.execute(&#39;&#39;&#39;
        DROP TABLE IF EXISTS changes;
        CREATE TABLE changes(id INTEGER PRIMARY KEY AUTOINCREMENT, change TEXT);
        &#39;&#39;&#39;)        
    
    def lastchanges(self):
        if self.countchanges()==0:
            ## no changes
            out = []
        else:
            cursor=self.cursor()
            cid, change = cursor.execute(&#39;&#39;&#39;
                SELECT id, change FROM changes
                ORDER BY id DESC LIMIT 1
                &#39;&#39;&#39;).fetchone()
            change = json.loads(change)
            if &#39;batch&#39; not in change:
                ## single change item
                out = [(cid, change)]
            else:
                ## possibly multiple change items in same batch
                rows = cursor.execute(&#39;&#39;&#39;
                    SELECT id, change FROM changes
                    WHERE json_extract(change, &#34;$.batch&#34;) = ? ORDER BY id&#39;&#39;&#39;, [change[&#39;batch&#39;]]).fetchall()   
                out = [(cid, json.loads(change)) for cid, change in rows]
                
        return out
    
    def deletechange(self, id):
        cursor=self.cursor()
        cursor.execute(&#39;DELETE FROM changes WHERE id = ?&#39;, [id])
        
    def addchange(self, new=None, old=None, batch=None):
        
        if new is None and old is None:
            return
            
        change = {}
        if new is None:
            ## this is a delete
            change[&#39;uid&#39;] = old[&#39;uid&#39;]
            change[&#39;-&#39;] = cleandata(old.data)
        elif old is None:
            ## this is add
            change[&#39;uid&#39;] = new[&#39;uid&#39;]
            change[&#39;+&#39;] = cleandata(new.data)
        else:
            ## item internals have changed
            change[&#39;uid&#39;] = new[&#39;uid&#39;]
            change.update(diff(old.data, new.data, new._changedkeys))
        
        change.setdefault(&#39;time&#39;, time.time())
        change.setdefault(&#39;rev&#39;, generateUUID())
        if batch is not None:
            change[&#39;batch&#39;] = batch
            
        change = json.dumps(change)
            
        cursor=self.cursor()
        row=cursor.execute(&#39;&#39;&#39;INSERT INTO changes (change) VALUES (?)&#39;&#39;&#39;, [change])

    def undo(self):
        &#39;&#39;&#39;
        Undo the last change to the graph.
        &#39;&#39;&#39;
        changes = []
        changebatch=reversed(self.lastchanges())
        for i, change in changebatch:
            if &#39;+&#39; in change and &#39;-&#39; not in change:
                ## change was to add item so undo removes it
                action = &#34;-&#34;
                item = self.getuid(change[&#39;uid&#39;])
                item.delete(setchange=False) 
            elif &#39;-&#39; in change and &#39;+&#39; not in change:
                ## change was to remove item so undo adds it
                action = &#34;+&#34;
                data = change[&#39;-&#39;]
                if &#39;startuid&#39; in data:
                    item = Edge(data, graph=self)
                else:
                    item = Node(data, graph=self)
                item.save(setchange=False)
            elif &#39;-&#39; in change and &#39;+&#39; in change:
                ## change was to add and remove internals so undo reverses them
                action = &#34;*&#34;
                item = self.getuid(change[&#39;uid&#39;])
                item.data = patch(item.data, change, reverse=True)
                item.save(setchange=False, force=True)
            else:
                raise GraphyDBException(&#39;Unknown undo action&#39;)
            changes.append((action, change[&#39;uid&#39;]))
            self.deletechange(i)
        return changes

    def resetfts(self, nodefields=None, edgefields=None):
                
        ## remove tables
        cursor=self.cursor()
        cursor.execute(&#39;&#39;&#39;
            DROP TABLE IF EXISTS nodefts;
            DROP TABLE IF EXISTS edgefts;
        &#39;&#39;&#39;) 
        
        ## create node table
        if nodefields is not None:
            nodefields = set(nodefields)
            VSTR = &#34;,&#34;.join(nodefields) + &#34;,uid UNINDEXED&#34;
            cursor.execute(&#39;CREATE VIRTUAL TABLE IF NOT EXISTS nodefts USING fts5({});&#39;.format(VSTR))
            
            
        ## create edge table
        if edgefields is not None:
            edgefields = set(edgefields)
            ESTR = &#34;,&#34;.join(edgefields)+&#34;,uid UNINDEXED&#34;
            cursor.execute(&#39;CREATE VIRTUAL TABLE IF NOT EXISTS edgefts USING fts5({});&#39;.format(ESTR))
        
    def getsetting(self, key):
        &#39;&#39;&#39;
        Read back a previously saved setting. Value will be de-jsonified.
        &#39;&#39;&#39;
        cursor=self.cursor()
        row = cursor.execute(&#39;SELECT value FROM settings WHERE key = ?&#39;,[key]).fetchone()
        if row is None:
            raise KeyError
        
        value = json.loads(row[0])
        return value
        
    def savesetting(self, key, value):
        &#39;&#39;&#39;
        A simple key-value store to save settings. Values will be jsonified.
        &#39;&#39;&#39;
        cursor=self.cursor()
        settings = cursor.execute(&#39;INSERT OR REPLACE INTO settings(key, value) VALUES(?,?)&#39;, (key, json.dumps(value)) )

    def cached(self, key):
        &#39;&#39;&#39;
        Read back a previously cached item. Value will be de-jsonified.
        &#39;&#39;&#39;
        cursor=self.cursor()
        row = cursor.execute(&#39;SELECT value FROM cache WHERE key = ?&#39;,[key]).fetchone()
        if row is None:
            raise KeyError
        return json.loads(row[0])
        
    def cache(self, key, value):
        &#39;&#39;&#39;
        A simple key-value store to serve as a cache. Values will be stored jsonified under the given key.
        &#39;&#39;&#39;
        cursor=self.cursor()
        settings = cursor.execute(&#39;INSERT OR REPLACE INTO cache(key, value) VALUES(?,?)&#39;, (key, json.dumps(value)) )

    def cursor(self):
        &#39;&#39;&#39;
        Return an APSW cursor.
        
        This can be used to excute SQL queries directly on the database.
        &#39;&#39;&#39;
        return self.connection.cursor()
    
    @property
    def stats(self):
        &#39;&#39;&#39;
        Return basic stats of the graph such as the number of edges and nodes.
        &#39;&#39;&#39;
        cursor=self.cursor()
        Nn = cursor.execute(&#39;SELECT COUNT(*) FROM nodes&#39;).fetchone()[0]
        Ne = cursor.execute(&#39;SELECT COUNT(*) FROM edges&#39;).fetchone()[0]
        
        nkinds = {}
        for k,n in cursor.execute(&#39;SELECT kind, COUNT(kind) FROM nodes GROUP BY kind&#39;):
            nkinds[k]=n
        ekinds = {}
        for k,n in cursor.execute(&#39;SELECT kind, COUNT(kind) FROM edges GROUP BY kind&#39;):
            ekinds[k]=n
        
        S = {&#34;Total nodes&#34;:Nn, &#34;Total edges&#34;:Ne, &#34;Node kinds&#34;:nkinds, &#34;Edge kinds&#34;:ekinds}
        
        if self.path!=&#39;:memory:&#39;:
            stat = os.stat(self.path)
            size = stat.st_size
            if size &lt; 1000:
                sizestr = &#34;%dB&#34;%size
            elif size &lt; 1000000:
                sizestr = &#34;%dK&#34;%(size/1000)
            else:
                sizestr = &#34;%dM&#34;%(size/1000000)
            S[&#39;File size&#39;]= sizestr
            
        sversion = cursor.execute(&#39;SELECT sqlite_version()&#39;).fetchone()[0] 
        S[&#39;SQLite version&#39;] = sversion
        S[&#39;GraphyDB version&#39;] = self.getsetting(&#39;GraphyDB version&#39;)
        
        S[&#39;Changes&#39;] = self.countchanges()
        
        return S

    def _parsechain(self, CHAIN, PARAM):
        &#39;&#39;&#39;
        Break down the chain of edges and nodes.
        &#39;&#39;&#39;
            
        aliases = {}
        collect = None
        left = None
        search1 = re.compile(&#39;\(([\w:]+)\)&#39;)
        search2 = re.compile(&#39;\[([\w:,]+)\]&#39;)
        for p in CHAIN.split():
            ## parse kind of item
            if p[-1] == &#39;&gt;&#39;:
                item = {&#39;type&#39;:&#39;right&#39;,&#39;table&#39;:&#39;edges&#39;,&#39;leftuid&#39;:&#39;startuid&#39;,&#39;rightuid&#39;:&#39;enduid&#39;,&#39;ftstable&#39;:&#39;edgefts&#39;,&#39;columns&#39;:[&#39;data&#39;]}
            elif p[0] == &#39;&lt;&#39;:
                item = {&#39;type&#39;:&#39;left&#39;,&#39;table&#39;:&#39;edges&#39;,&#39;leftuid&#39;:&#39;enduid&#39;,&#39;rightuid&#39;:&#39;startuid&#39;,&#39;ftstable&#39;:&#39;edgefts&#39;,&#39;columns&#39;:[&#39;data&#39;]}
            else:
                item = {&#39;type&#39;:&#39;node&#39;,&#39;table&#39;:&#39;nodes&#39;,&#39;leftuid&#39;:&#39;uid&#39;,&#39;rightuid&#39;:&#39;uid&#39;,&#39;ftstable&#39;:&#39;nodefts&#39;,&#39;columns&#39;:[&#39;data&#39;]}
                
            ## parse aliases, extra parameters and kinds
            so1=search1.search(p)
            so2=search2.search(p)
            if so1:
                tmp = so1.group(1).split(&#39;:&#39;)
                alias=tmp[0]
                if len(tmp)==2:
                    item[&#34;kind&#34;]=tmp[1]
    
            elif so2:
                s = so2.group(1).split(&#34;,&#34;)
                tmp = s[0].split(&#39;:&#39;)
                alias=tmp[0]     
                collect = item
                if len(s)&gt;1:
                    item[&#39;extra&#39;] = {}
                    for c in s[1:]:
                        try:
                            col = &#39;{} AS &#34;{}&#34;&#39;.format(PARAM[c],c)
                        except KeyError:
                            raise GraphyDBException(&#39;Item &#34;{}&#34; not given an expansion&#39;.format(c))
                        item[&#39;extra&#39;][c]=col
                        ## remove these extra columns from parameters
                        del PARAM[c]
                if len(tmp)==2:
                    item[&#34;kind&#34;]=tmp[1]

            else:
                raise GraphyDBException(&#34;Error in parsing format: &#39;{}&#39;&#34;.format(p) )
            
            if alias in aliases:
                raise GraphyDBException(&#34;Aliases must be unique ({} multiply defined)&#34;.format(alias) )
            
            
            item[&#39;alias&#39;] = alias
            
            ## link
            if left is not None:
                item[&#39;leftlink&#39;] = left[&#39;alias&#39;]
                left[&#39;rightlink&#39;] = item[&#39;alias&#39;]   
                
            aliases[alias]=item
            left = item
        
        if collect is None:
            collect = item
    
        return aliases, collect
    
    def fetch(self, CHAIN=&#39;(n)&#39;, WHERE=None, **args):
        &#39;&#39;&#39;
        This is the workhorse for fetching nodes and edges from the database. It&#39;s a thin wrapper around
        SQL so most of the SQL operators are available.
        
        **Keywords**
        
        - `CHAIN`: Description of how to join together nodes and edges for the query. 
                   A chain is composed of links read from left to right separated by spaces. 
                   Each link can be a node &#34;(n)&#34; or and edge &#34;-(e)&gt;&#34; or &#34;&lt;(e)-&#34;. 
                   e.g. &#34;(n1) -[e:Document,title]&gt; (n2)&#34;.
                   The variable in the brackets is an alias for the link that can then be used 
                   in other parts of the query and should be unique. 
                   Square brackets indicate the link to be collected (otherwise defaults to right-most link).
                   Square brackets can also have other aliases separated by commas, these should be defined in parameters passed
                   to the function.
        - `WHERE`: A string, or list of strings with SQL conditions. If it&#39;s a list the items will be ANDed together
        - `GROUP`: String to follow SQLs GROUP BY
        - `ORDER`: String to follow SQLs ORDER BY
        - `LIMIT`: An interger to limit the numer of items returned
        - `OFFSET`: Return items from offset, used in combination with `LIMIT`
        - `COUNT`: The number of items satisfying the query will be returned
        - `DISTINCT`: Distinct uids will be collected. [Defaults to `True`]
        - `DEBUG`: If this is set to `True` the generated SQL and parameters will be returned without making the query.
        
        For convenience `CHAIN` and `WHERE` are the first two implicit parameters.
        
        **Parameters**
        
        Every other keyword is treated as a parameter for defining returned values, FTS searches or SQL escaped parameters. 
        
        Any extra aliases in the collected item should be defined as a parameter. The result will be available as a key 
        in the item with the alias preceded by an underscore (i.e. an unsaved value). 
        
        If a parameter is the same as a link-alias with &#34;_fts&#34; appended then the value is to be
        used in an FTS match. 
        
        Values to be SQL escaped whould be inserted by name (e.g. &#39;:p1&#39;) where appropriate and the value given by a parameter
        (e.g. p1=10).
        
        **Example**
        
            # Fetch the nodes of kind &#34;Person&#34; that are  
            # connected by edges of kind &#34;Author&#34; to other 
            # nodes of kind &#34;Document&#34; with tiles containing &#34;Quantum&#34;
            # and also collect the author order
            g.fetch(&#39;(n:Document) &lt;(e:Author)- [p:Person,aorder]&#39;, n_fts=&#39;title: Quantum&#39;, aorder=&#39;e.data.order&#39;)
        &#39;&#39;&#39;
        
        ## extract the SQL pieces with sensible defaults
        WHERE=ensurelist(WHERE)
        ORDER=args.get(&#39;ORDER&#39;, None)
        GROUP=args.get(&#39;GROUP&#39;, None)
        LIMIT=args.get(&#39;LIMIT&#39;, None)
        OFFSET=args.get(&#39;OFFSET&#39;, None)
        COUNT=args.get(&#39;COUNT&#39;, False)
        DISTINCT=args.get(&#39;DISTINCT&#39;, True)    
        DEBUG=args.get(&#39;DEBUG&#39;, False)

        ## everything else is a parameter of some sort
        PARAM = {k:v for k,v in args.items() if k not in FETCHKEYWORDS}
                    
        ## interpret table joins
        aliases, collect = self._parsechain(CHAIN, PARAM)
            
        SQL = []

        SQLFTS = []
        ## SQL to attach FTS tables ... need to do this fist so we can expand fts aliases with tablename
        ftsexpansions = {}
        for k in aliases.keys():
            ftskey = k+&#39;_fts&#39;
            if ftskey in list(PARAM.keys()):
                ## N.B. want a copy of PARAM.keys() as we might modify PARAM
                item = aliases[k]
                SQLFTS.append(&#39;\nJOIN {ftstable} &#34;{ftskey}&#34; ON {alias}.uid = {ftskey}.uid&#39;.format(
                    ftstable=item[&#39;ftstable&#39;], ftskey=ftskey, alias=k))
                ## add an item to PARAM with the FTS term so it&#39;s SQL escaped
                valuekey = ftskey+&#39;_value&#39;
                ## N.B. proper reference using alias has to have table name, e.g. n1_fts.nodefts
                WHERE.append(&#39;{ftskey}.{ftstable} MATCH :{ftsvalue}&#39;.format(
                    ftskey=ftskey, ftstable=aliases[k][&#39;ftstable&#39;], ftsvalue=valuekey))
                PARAM[valuekey] = PARAM[ftskey]
                del PARAM[ftskey]
                ftsexpansions[ftskey] = &#34;{}.{}&#34;.format(ftskey,aliases[k][&#39;ftstable&#39;])
            
        def expandfts(ftsstring, ftsexpansions):
            for ftskey, ftsexpanded in ftsexpansions.items():
                ftsstring = ftsstring.replace(ftskey, ftsexpanded)
            return ftsstring
            
        ##
        ## SELECT
        ##
        collect[&#39;distinct&#39;] = &#39;DISTINCT&#39; if DISTINCT else &#39;&#39;
        colkeys = collect[&#39;columns&#39;].copy()
        colsql = [&#39;{}.{}&#39;.format(collect[&#39;alias&#39;],c) for c in colkeys]
        for k,v in collect.get(&#39;extra&#39;,{}).items():
            colkeys.append(k)
            v = jsonextract(v)
            v = expandfts(v, ftsexpansions)
            colsql.append(v)

        collect[&#39;collectcolumns&#39;] = &#39;, &#39;.join(colsql)
        if COUNT:
            SQL.append(&#39;SELECT COUNT({distinct} {alias}.uid) FROM {table} {alias}&#39;.format(**collect))
        else:
            SQL.append(&#39;SELECT {distinct} {collectcolumns} FROM {table} {alias}&#39;.format(**collect))
    
        
        ##
        ## JOINs
        ##
        ## link tables together
        l = collect        
        while &#39;rightlink&#39; in l:
            r = aliases[l[&#39;rightlink&#39;]]
            r[&#39;join&#39;] = &#39;{}.{} = {}.{}&#39;.format(r[&#39;alias&#39;], r[&#39;leftuid&#39;], l[&#39;alias&#39;], l[&#39;rightuid&#39;])
            if &#39;kind&#39; in r:
                r[&#39;join&#39;] += &#39; AND {}.kind = &#34;{}&#34;&#39;.format(r[&#39;alias&#39;],r[&#39;kind&#39;])
            SQL.append(&#39;\nJOIN {table} {alias} ON {join}&#39;.format(**r))
            l=r
        r = collect
        while &#39;leftlink&#39; in r:
            l = aliases[r[&#39;leftlink&#39;]]
            l[&#39;join&#39;] = &#39;{}.{} = {}.{}&#39;.format(l[&#39;alias&#39;], l[&#39;rightuid&#39;], r[&#39;alias&#39;], r[&#39;leftuid&#39;] )  
            if &#39;kind&#39; in l:
                l[&#39;join&#39;] += &#39; AND {alias}.kind = &#34;{kind}&#34;&#39;.format(**l)
            SQL.append(&#39;\nJOIN {table} {alias} ON {join}&#39;.format(**l))
            r=l
    
        SQL.extend(SQLFTS)
        
        ##
        ## WHERE
        ##
        if &#39;kind&#39; in collect:
            WHERE.append(&#39;{alias}.kind = &#34;{kind}&#34;&#39;.format(**collect))

        if len(WHERE)&gt;0:
            SQL.append(&#39;\nWHERE &#39;+ &#39; AND &#39;.join([jsonextract(w) for w in WHERE]))
        

        ##
        ## GROUP BY
        ##
        if GROUP is not None:
            SQL.append(&#39;\nGROUP BY {}&#39;.format(expandfts(jsonextract(GROUP), ftsexpansions)))
        
        ##
        ## ORDER BY
        ##
        if ORDER is not None:
            SQL.append(&#39;\nORDER BY {}&#39;.format(expandfts(jsonextract(ORDER),ftsexpansions)))
        
            
        ##
        ## LIMIT and OFFSET
        ##
        if LIMIT is not None:
            SQL.append(&#39;\nLIMIT {}&#39;.format(LIMIT))
        if OFFSET is not None:
            SQL.append(&#39; OFFSET {}&#39;.format(OFFSET))
    
        SQL = &#39;&#39;.join(SQL)
        ##
        ## Return sql statement if debug
        ##
        if DEBUG:
            return SQL, PARAM
        
        cursor=self.cursor()
            
        ## faster to first create list
        items = []
        
        ##
        ## COUNT
        ##
        if COUNT:
            c = cursor.execute(SQL, PARAM).fetchone()[0]
            return c
        
        ##
        ## COLLECT
        ##        
        elif collect[&#39;type&#39;]==&#39;node&#39;:
            for row in cursor.execute(SQL, PARAM):
                args = json.loads(row[colkeys.index(&#39;data&#39;)])
                for c,v in zip(colkeys, row):
                    if c == &#39;data&#39;:
                        continue                        
                    else:
                        args[&#39;_&#39;+c] = v
                N = Node(args, graph=self, changed=False)
                items.append(N)
            return NSet(items)
        
        else:
            for row in cursor.execute(SQL, PARAM):
                args = json.loads(row[colkeys.index(&#39;data&#39;)])
                for c,v in zip(colkeys, row):
                    if c == &#39;data&#39;:
                        continue                        
                    else:
                        args[&#39;_&#39;+c] = v
                E = Edge(args, graph=self, changed=False)
                items.append(E)
            return ESet(items)

    def exists(self, uid):
        &#39;&#39;&#39;
        Return if item exists in the database as a node or edge. UIDs are big and bad enough that they should be
        unique across all intances of nodes and edges.
        &#39;&#39;&#39;
        cursor = self.cursor()
        n = cursor.execute(&#39;SELECT COUNT(*) FROM nodes WHERE uid = ?&#39;,[uid]).fetchone()[0]
        if n==1:
            return True
        else:
            n = cursor.execute(&#39;SELECT COUNT(*) FROM edges WHERE uid = ?&#39;,[uid]).fetchone()[0]
            if n==1:
                return True      
            else:
                return False 

    def getuid(self, uid):
        &#39;&#39;&#39;
        Convenience function to find either a node or edge with a given uid.
        &#39;&#39;&#39;
        
        obj = self.fetch(CHAIN=&#39;(n)&#39;, WHERE=&#39;n.uid = :uid&#39;, uid=uid).one
        if obj is None:
            obj = self.fetch(CHAIN=&#39;-(e)&gt;&#39;, WHERE=&#39;e.uid = :uid&#39;, uid=uid).one
            
        return obj
    
    def Node(self, kind=None, **args):
        &#39;&#39;&#39;
        Convenience method to create a new `graphydb.Node` and linked to the database.
        &#39;&#39;&#39;
        args[&#39;kind&#39;] = kind
        return Node(args, graph=self)
    
    def Edge(self, startuid=None, kind=None, enduid=None, **args):
        &#39;&#39;&#39;
        Convenience method to create a new `graphydb.Edge` linked to the database.
        &#39;&#39;&#39;
        
        if isinstance(startuid, Node):
            startuid = startuid[&#39;uid&#39;]
        if isinstance(enduid, Node):
            enduid = enduid[&#39;uid&#39;]  
        args.update({&#39;kind&#39;:kind,&#39;startuid&#39;:startuid, &#39;enduid&#39;:enduid })
            
        return Edge(args, graph=self)
    
#-------------------------------------------------------------------------------- 
class GraphyDBItem(MutableMapping):
    &#39;&#39;&#39;
    Parent of `graphydb.Node` and `graphydb.Edge` with some common methods. Essentially acts as souped up `dict`.
    &#39;&#39;&#39;
    
    ## set in derived classes
    _table = &#39;&#39;
    _ftstable = &#39;&#39;    
    
    def __init__(self, data, graph=None, changed=True):
        &#39;&#39;&#39;
        GraphyDBItem shoudn&#39;t be instantiated directly. Use `graphydb.Node` or `graphydb.Edge` instead.
        &#39;&#39;&#39;
        
        self.graph = graph
        &#39;&#39;&#39;
        An instance of the `graphydb.Graph` holding the item.
        &#39;&#39;&#39;                
        
        if &#39;uid&#39; not in data:
            data[&#39;uid&#39;] = generateUUID()   
        if &#39;ctime&#39; not in data:
            data[&#39;ctime&#39;] = time.time()
        if &#39;mtime&#39; not in data:
            data[&#39;mtime&#39;] = time.time()         
        
        self.data = data
        &#39;&#39;&#39;Straight python dictionary that holds all the data. Keys begining with an underscore (&#34;_&#34;)
        will be ignored when saving and can be used to store local temporary data.
        Modifying the data directly is not recommended as what&#39;s changed will not be recorded.&#39;&#39;&#39;    
        
        self.setChanged(changed)      
      
    def setGraph(self, graph, changed=True):
        &#39;&#39;&#39;
        Set the graph for the item.
        &#39;&#39;&#39;
        self.graph = graph
        
        self.setChanged(changed)      
        return self
      
    def __uid__(self):
        return self.data[&#39;uid&#39;]
    
    def setChanged(self, changed):
        &#39;&#39;&#39;
        Mark all keys as having changed.
        &#39;&#39;&#39;
        if changed:
            ## regard all keys as having changed
            self._changedkeys = set(self.keys())
        else:
            self._changedkeys = set()   
            
    @property   
    def changed(self):
        &#39;&#39;&#39;
        Returns True is any key is marked as changed.
        &#39;&#39;&#39;
        return len(self._changedkeys)&gt;0
        
    @property
    def exists(self):
        &#39;&#39;&#39;
        Property: return True if item exists in the database otherwise False.
        &#39;&#39;&#39;
        cursor = self.graph.cursor()
        n = cursor.execute(&#39;SELECT COUNT(*) FROM {} WHERE uid = ?&#39;.format(self._table), (self[&#39;uid&#39;],)).fetchone()[0]
        if n==1:
            return True
        else:
            return False    

    def original(self):
        &#39;&#39;&#39;
        Return item fresh from database. 
        &#39;&#39;&#39;
        item = self.graph.getuid(self[&#39;uid&#39;])
        return item
    
    def renew(self):
        &#39;&#39;&#39;
        Load data from database again. 
        Any local changes are discarded without setting a change item.
        Keys starting with an underscore are undisturbed.
        &#39;&#39;&#39;
        original = self.original()
        ## copy accross the undescore keys
        for k,v in self.data.items():
            if k[0]==&#39;_&#39;:
                original.data[k] = v
                
        ## copy across the refreshed dataset
        self.data = original.data
        self.setChanged(False)
        return self
        
    def updatefts(self, **data):
        &#39;&#39;&#39;
        Update FTS for the item.
        &#39;&#39;&#39;
        if len(data)&gt;0:
            cursor = self.graph.cursor()
            
            ## filter on existing column names
            columnames = [x[1] for x in cursor.execute(&#39;PRAGMA table_info({})&#39;.format(self._ftstable)).fetchall()]
            keys = []
            values = []
            for k,v in data.items():
                if k in columnames:
                    keys.append(k)
                    values.append(v)
            if len(keys)==0:
                return
            
            n = cursor.execute(&#34;SELECT COUNT(*) FROM {} WHERE uid = ?&#34;.format(self._ftstable), [self[&#39;uid&#39;]]).fetchone()[0]
            if n &gt; 0:
                ## use UPDATE
                keystr = &#34;,&#34;.join( [&#34;{} = ?&#34;.format(k) for k in keys] )
                query = &#39;UPDATE {} SET {} WHERE uid = &#34;{}&#34;&#39;.format(self._ftstable, keystr, self[&#39;uid&#39;])
            else:
                ## use INSERT
                keystr = &#34;,&#34;.join(keys)+&#34;,uid&#34;
                values.append(self[&#39;uid&#39;])
                qstr = &#34;,&#34;.join([&#39;?&#39;]*len(values))
                query = &#39;INSERT INTO {}({}) VALUES ({})&#39;.format(self._ftstable, keystr, qstr)
                
            cursor.execute(query, values)
        return self

            
    def set(self, **attr):
        &#39;&#39;&#39;
        Set a bunch of keys in one go.
        &#39;&#39;&#39;
        for k,v in attr.items():
            self[k] = v
            self._changedkeys.add(k)
        return self

    def __getitem__(self, key):
        if key in self.data:
            return self.data[key]
        if hasattr(self.__class__, &#34;__missing__&#34;):
            return self.__class__.__missing__(self, key)
        raise KeyError(key)
    
    def __setitem__(self, key, item):
        self.data.__setitem__(key, item)
        if key != &#39;mtime&#39;:
            # avoid recursion!
            self[&#39;mtime&#39;] = time.time()
        self._changedkeys.add(key)
        
    def __delitem__(self, key):
        self.data.__delitem__(key)
        if key != &#39;mtime&#39;:
            # avoid recursion!
            self[&#39;mtime&#39;] = time.time()
        self._changedkeys.add(key)
    
    def deletefts(self):
        &#39;&#39;&#39;
        Remove the FTS data for this item.
        &#39;&#39;&#39;
        cursor = self.graph.cursor()
        if cursor.execute(&#34;SELECT count(*) FROM sqlite_master WHERE type=&#39;table&#39; AND name=&#39;{}&#39;;&#34;.format(self._ftstable)).fetchone()[0] &gt;0:
            cursor.execute(&#39;DELETE FROM {} WHERE uid = ?&#39;.format(self._ftstable), (self[&#39;uid&#39;],))
        return self
            
    def __len__(self): 
        return len(self.data)

    def __iter__(self):
        return iter(self.data)

    def __contains__(self, key):
        return key in self.data

    ## Now, add the methods in dicts but not in MutableMapping
    
    def __repr__(self): 
        return repr(self.data)
    
    def copy(self):
        data = self.data
        try:
            self.data = {}
            c = copy.copy(self)
        finally:
            self.data = data
        c.update(self)
        c._changedkeys = set(self._changedkeys)
        return c
    
    def deepcopy(self):
        data = self.data
        try:
            self.data = {}
            c = copy.deepcopy(self)
        finally:
            self.data = data
        c.data = copy.deepcopy(data)
        return c        
    
    @classmethod
    def fromkeys(cls, iterable, value=None):
        d = cls()
        for key in iterable:
            d[key] = value
            self._changedkeys.add(key)
        return d


#-------------------------------------------------------------------------------- 
class Node(GraphyDBItem):
    &#39;&#39;&#39;
    A Node object
    can contain abitrary key value pairs as long as they are JSONifiable 
    &#39;&#39;&#39;
    
    _table = &#39;nodes&#39;
    _ftstable = &#39;nodefts&#39;
    
    def __init__(self, data, graph=None, changed=True):
        if data.setdefault(&#39;kind&#39;, None) is None:
            raise GraphyDBException(&#34;Must supply Node kind&#34;)        
        super().__init__(data, graph=graph, changed=changed)
        
    def save(self, force=False, batch=None, setchange=True):
        &#39;&#39;&#39;
        Save the data to the database. Any keys that begin with &#34;_&#34; will *not* be saved.
        
        - `force`: if `True` will save regardless if item marked as changed.
        &#39;&#39;&#39;
        ## ignore if unforced and not changed
        if not force and not self.changed:
            return self        
        
        cursor = self.graph.cursor()
        data = cleandata(self.data)
                
        if setchange:
            originalitem = self.original()
        
        cursor.execute(&#34;INSERT OR REPLACE INTO nodes(uid, kind, ctime, mtime, data) VALUES(?,?,?,?,?)&#34;, 
                       (self[&#39;uid&#39;], self[&#39;kind&#39;], self[&#39;ctime&#39;], self[&#39;mtime&#39;], json.dumps(data)) )
        
        if setchange:
            self.graph.addchange(old=originalitem, new=self, batch=batch)                        
        
        self.setChanged(False)
        return self
        
        
    def inE(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Fetch incomming edges i.e. &#34;&lt;[e]-&#34; with &#34;e.enduid = self.uid&#34; 
        (see `Graph.fetch` for details)
        &#39;&#39;&#39;
        args[&#39;CHAIN&#39;] = &#39;&lt;(e)-&#39;
        args[&#39;WHERE&#39;] = ensurelist(WHERE)
        args[&#39;WHERE&#39;].insert(0,&#39;e.enduid = :node_uid&#39;)
        args[&#39;node_uid&#39;] = self[&#39;uid&#39;]
            
        return self.graph.fetch(**args)
        
    def outE(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Fetch outgoing edges, i.e. &#34;-[e]&gt;&#34; with &#34;e.startuid = self.uid&#34; 
        (see `Graph.fetch` for details)
        &#39;&#39;&#39;
        args[&#39;CHAIN&#39;] = &#39;-(e)&gt;&#39;
        args[&#39;WHERE&#39;] = ensurelist(WHERE)
        args[&#39;WHERE&#39;].insert(0,&#39;e.startuid = :node_uid&#39;)
        args[&#39;node_uid&#39;] = self[&#39;uid&#39;]
            
        return self.graph.fetch(**args)   
    
    def bothE(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Get edges both incomming and outgoing 
        (see `Graph.fetch` for details)
        &#39;&#39;&#39;
        args[&#39;WHERE&#39;] = ensurelist(WHERE)
        ## A deep copy is necessary as inE and outE 
        ## modify the dict or lists withing the dict
        if args.get(&#39;COUNT&#39;, False):
            ## COUNT=True will fail as it doesn&#39;t check uniqueness across   
            ## in and out sets fetch actual items and count in python
            args[&#39;COUNT&#39;] = False
            ine = self.inE(**copy.deepcopy(args))
            oute = self.outE(**copy.deepcopy(args))            
            return len(ine|oute)
        else:
            ine = self.inE(**copy.deepcopy(args))
            oute = self.outE(**copy.deepcopy(args))            
            ## union of sets
            return ine | oute 
    
    def inN(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Fetch nodes on an incomming edge i.e. &#34;&lt;(e)- [n]&#34; with &#34;e.enduid = self.uid&#34; 
        (see `Graph.fetch` for details)
        &#39;&#39;&#39;
        args[&#39;CHAIN&#39;] = &#39;&lt;(e)- [n]&#39;
        args[&#39;WHERE&#39;] = ensurelist(WHERE)     
        args[&#39;WHERE&#39;].insert(0,&#39;e.enduid = :node_uid&#39;)
        args[&#39;node_uid&#39;] = self[&#39;uid&#39;]
            
        return self.graph.fetch(**args) 
    
    def outN(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Fetch nodes on an outgoing edge &#34;-(e)&gt; [n]&#34; with &#34;e.startuid = self.uid&#34; 
        (see `Graph.fetch` for details)
        &#39;&#39;&#39;
        args[&#39;CHAIN&#39;] = &#39;-(e)&gt; [n]&#39;
        args[&#39;WHERE&#39;] = ensurelist(WHERE)        
        args[&#39;WHERE&#39;].insert(0,&#39;e.startuid = :node_uid&#39;)
        args[&#39;node_uid&#39;] = self[&#39;uid&#39;]
            
        return self.graph.fetch(**args) 
    
    def bothN(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Fetch nodes connected by edge 
        (see `Graph.fetch` for details)
        &#39;&#39;&#39;
        args[&#39;WHERE&#39;] = ensurelist(WHERE)
        ## A deep copy is necessary as inE and outE 
        ## modify the dict or lists withing the dict 
        if args.get(&#39;COUNT&#39;, False):
            ## COUNT=True will fail as it doesn&#39;t check uniqueness across    
            ## in and out sets fetch actual items and count in python
            args[&#39;COUNT&#39;] = False
            inn = self.inN(**copy.deepcopy(args))
            outn = self.outN(**copy.deepcopy(args))              
            return len(inn|outn)
        else:
            inn = self.inN(**copy.deepcopy(args))
            outn = self.outN(**copy.deepcopy(args))            
            ## union of sets
            return inn | outn         
            
    def delete(self, disconnect=False, batch=None, setchange=True):
        &#39;&#39;&#39;
        Delete this node from the database.
        
        `disconnect`: If `True`, silently delete any connected edges, else raise an Exception
        if the node is connected and deleting it would leave the graph inconsistent.
        &#39;&#39;&#39;
        cursor = self.graph.cursor()
        if self.outE(COUNT=True)+self.inE(COUNT=True) &gt; 0:
            if disconnect:
                if setchange and batch is None:
                    ## if no batch set, set one now to group all the edges and node in a single change set
                    batch = generateUUID()                 
                for edge in self.bothE():                
                    edge.delete(batch=batch, setchange=setchange)                           
            else:
                raise GraphyDBException(&#34;Node still connected. Delete Edges First&#34;)
        
        cursor.execute(&#39;DELETE FROM nodes WHERE uid = ?&#39;, (self[&#39;uid&#39;],))
        
        if setchange:  
            self.graph.addchange(old=self, batch=batch)
        
        
        self.deletefts()
        self[&#39;mtime&#39;] = time.time()
        self.setChanged(True)
        return self
        
    def __repr__(self):
        return &#39;({uid}:{kind})&#39;.format(**self.data)
   
#-------------------------------------------------------------------------------- 
class Edge(GraphyDBItem):
    &#39;&#39;&#39;
    A Edge object
    can contain abitrary key value pairs as long as they are JSONifiable 
    &#39;&#39;&#39;
    
    _table = &#39;edges&#39;
    _ftstable = &#39;edgefts&#39;
    
    def __init__(self, data, graph=None, changed=True):
        
        if data.setdefault(&#39;kind&#39;, None) is None:
            raise GraphyDBException(&#34;Must supply edge kind&#34;)      
            
        if data.setdefault(&#39;startuid&#39;, None) is None:
            raise GraphyDBException(&#34;Wrong type or missing start node&#34;)

        if data.setdefault(&#39;enduid&#39;, None) is None:
            raise GraphyDBException(&#34;Wrong type or missing end node&#34;)

        super().__init__(data, graph=graph, changed=changed)
        
    def save(self, force=False, batch=None, setchange=True):
        &#39;&#39;&#39;
        Save the data to the database. Any keys that begin with &#34;_&#34; will *not* be saved.
        
        - `force`: if `True` will save regardless if item marked as changed.
        &#39;&#39;&#39;
        
        ## ignore if unforced and not dirty
        if not force and not self.changed:
            return self
        
        if not self.graph.exists(self[&#39;startuid&#39;]): 
            raise GraphyDBException(&#39;start node referenced from edge does not exist in DB.&#39;)
        if not self.graph.exists(self[&#39;enduid&#39;]):
            raise GraphyDBException(&#39;end node referenced from edge does not exist in DB.&#39;)
        
        data = cleandata(self.data)   
                
        if setchange:
            originalitem = self.original()                

        cursor = self.graph.cursor()
        cursor.execute(&#34;INSERT OR REPLACE INTO edges(uid, startuid, kind, enduid, ctime, mtime, data) VALUES(?,?,?,?,?,?,?)&#34;, 
                       (self[&#39;uid&#39;], self[&#39;startuid&#39;], self[&#39;kind&#39;], self[&#39;enduid&#39;], self[&#39;ctime&#39;], self[&#39;mtime&#39;], json.dumps(data)) )
        
        if setchange:
            self.graph.addchange(old=originalitem, new=self, batch=batch)                        
        
        self.setChanged(False)
        return self

            
    def delete(self, setchange=True, batch=None):
        &#39;&#39;&#39;
        Delete edge from database.
        &#39;&#39;&#39;
        cursor = self.graph.cursor()
        cursor.execute(&#39;DELETE FROM edges WHERE uid = ?&#39;, (self[&#39;uid&#39;],))
        self.deletefts()
        self[&#39;mtime&#39;] = time.time()
        
        if setchange:
            self.graph.addchange(old=self, batch=batch)
        
        self.setChanged(True)
        return self
            
    @property
    def start(self):
        &#39;&#39;&#39;
        Return node at start of directed edge
        &#39;&#39;&#39;
        return self.graph.fetch(CHAIN=&#39;(n)&#39;, WHERE=&#39;n.uid = :start_uid&#39;, start_uid=self[&#39;startuid&#39;]).pop()
    
    @property
    def end(self):
        &#39;&#39;&#39;
        Return node at end of directed edge
        &#39;&#39;&#39;
        return self.graph.fetch(CHAIN=&#39;(n)&#39;, WHERE=&#39;n.uid = :end_uid&#39;, end_uid=self[&#39;enduid&#39;]).pop()
    
    def __repr__(self):
        return &#39;({startuid})-[{uid}:{kind}]-&gt;({enduid})&#39;.format(**self.data)
       

#--------------------------------------------------------------------------------    
class GraphyDBItemSet(IndexedSet):
    &#39;&#39;&#39;
    Super class of sets `graphydb.NSet` and `graphydb.ESet` holding nodes and edges.
    Operations between sets will be based entirely on the items  `__uid__()` not on their content.
    Methods will return a reference to itself where appropriate to allow chaining of commands.
    &#39;&#39;&#39;
    
    def setGraph(self, graph, changed=True):
        &#39;&#39;&#39;
        Set the graph on all contained items. Items not saved to new graph automatically.
        &#39;&#39;&#39;
        for item in self:
            item.setGraph(graph, changed)
        return self
    
    def save(self, force=False, batch=None, setchange=True):
        &#39;&#39;&#39;
        Save all items to the database.
        
        - `force`: if `True`, save regardless if the item has changed.
        &#39;&#39;&#39;
        if batch is None:
            ## since we&#39;re saving in a group this should be batched
            batch = generateUUID()        

        for item in self:
            item.save(force=force, batch=batch, setchange=setchange)
        return self
            
    
    def filter(self, function):
        &#39;&#39;&#39;
        Pythonic filter method on the set. Returns a set with items where the function
        returns `True`. Returned items are referenced not copies.
        
            fruits = [&#39;Orange&#39;,&#39;Apple&#39;,&#39;Pear&#39;]
            barset = fooset.filter(lambda n: n[&#39;fruit&#39;] in fruits])
        &#39;&#39;&#39;
        ## ensure we have the same type of set: either NSet or Eset
        out = self.__class__()
        
        ## this way is about twice as slow as using filter
        ## but we can make it insensitive to missing keys etc
        for item in self:
            try:
                if function(item):
                    out.add(item)
            except:
                pass
        return out
    
    def filter_fnmatch(self, **attr):
        &#39;&#39;&#39;
        Apply `fnmatch` to all the keys given and return the set of items that match. 
        Returned items are referenced not copies.
        
            barset = fooset.filter_fnmatch(title=&#39;Once Upon *&#39;)
        &#39;&#39;&#39;
        
        out = self.__class__()
        
        for item in self:
            found = True
            for key, pattern in attr.items():
                try:
                    found = found and fnmatch.fnmatch(item[key], pattern)
                except KeyError:
                    found = False
                    break  
            if found:
                out.add(item)
                
        return out
    
    @property
    def one(self):
        &#39;&#39;&#39;
        Return a single item from set or `None` if empty. Set not modified.
        &#39;&#39;&#39;
        if len(self)==0:
            return None
        else:
            return self[0]

    def get(self, key, default=None):
        &#39;&#39;&#39;
        Get the values of the key for each item in the set as a list. 
        Return the `default` for each item without that key.
        &#39;&#39;&#39;
        out = []
        for item in self:
            out.append(item.get(key, default))
        return out

    def getm(self, *keys, default=None):
        &#39;&#39;&#39;
        Get a list of values of the keys for each item in the set as a list. 
        Return the `default` for each item without a key.
        &#39;&#39;&#39;
        out = []
        for item in self:
            out.append([item.get(key, default) for key in keys])
        return out  
  
    def set(self, **attr):
        &#39;&#39;&#39;
        Set a bunch of attributes in one go on each item in the set.
        &#39;&#39;&#39;
        for item in self:
            item.set(**attr)
        return self
    
    def deletefts(self):
        &#39;&#39;&#39;
        Remove the FTS data from the database for the items in the set.
        &#39;&#39;&#39;
        for item in self:
            item.deletefts()
        return self
            
    
#--------------------------------------------------------------------------------    
class ESet(GraphyDBItemSet):
    &#39;&#39;&#39;
    A set holding edges with some agregate functionality.
    &#39;&#39;&#39;
    
    @property
    def end(self):
        &#39;&#39;&#39;
        The nodes at the ends of the edges in the set. Fetched from the database.
        &#39;&#39;&#39;
        out = NSet()
        for e in self:
            out.add(e.end)
        return out
    
    @property
    def start(self):
        &#39;&#39;&#39;
        The nodes at the start of the edges in the set. Fetched from the database.
        &#39;&#39;&#39;
        out = NSet()
        for e in self:
            out.add(e.start)
        return out

    def delete(self, batch=None, setchange=True):
        &#39;&#39;&#39;
        Delete the items from the *database*.
        N.B. don&#39;t confuse with remove() and discard() which work only on the set!
        &#39;&#39;&#39;
        if setchange and batch is None:
            ## since we&#39;re deleting in a group this should be batched
            batch = generateUUID()
            
        for item in self:
            item.delete(batch=batch, setchange=setchange)
            
#--------------------------------------------------------------------------------    
class NSet(GraphyDBItemSet):
    &#39;&#39;&#39;
    A set holding nodes with some agregate functionality.
    &#39;&#39;&#39;    
    
    def inE(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Fetch incoming edges to all the nodes in the set.
        &#39;&#39;&#39;
        out = ESet()
        args[&#39;WHERE&#39;] = ensurelist(WHERE)
        for v in self:
            out.update(v.inE(**copy.deepcopy(args)))
        return out
    
    def outE(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Fetch outgoing edges to all the nodes in the set.
        &#39;&#39;&#39;
        out = ESet()
        args[&#39;WHERE&#39;] = ensurelist(WHERE)
        for v in self:
            out.update(v.outE(**copy.deepcopy(args)))
        return out
    
    def bothE(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Fetch both incoming and outgoing edges to all the nodes in the set.
        &#39;&#39;&#39;
        out = ESet()
        args[&#39;WHERE&#39;] = ensurelist(WHERE)
        for v in self:
            out.update(v.bothE(**copy.deepcopy(args)))
        return out
    
    def inN(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Fetch nodes on an incomming edge to the nodes in the set. 
        This may include nodes in the set itself.
        &#39;&#39;&#39;
        out = NSet()
        args[&#39;WHERE&#39;] = ensurelist(WHERE)
        for v in self:
            out.update(v.inN(**copy.deepcopy(args)))
        return out
    
    def outN(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Fetch nodes on outgoing edges to the nodes in the set.
        This may include nodes in the set itself.
        &#39;&#39;&#39;
        out = NSet()
        args[&#39;WHERE&#39;] = ensurelist(WHERE)
        for v in self:
            out.update(v.outN(**copy.deepcopy(args)))
        return out
    
    def bothN(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Fetch nodes attached to the nodes in the set.
        This may include nodes in the set itself.
        &#39;&#39;&#39;
        out = NSet()
        args[&#39;WHERE&#39;] = ensurelist(WHERE)
        for v in self:
            out.update(v.bothN(**copy.deepcopy(args)))
        return out    
    
    def delete(self, disconnect=False, batch=None, setchange=True):
        &#39;&#39;&#39;
        Delete the items from the *database*.
        N.B. don&#39;t confuse with remove() and discard() which work only on the set!
        &#39;&#39;&#39;
        if setchange and batch is None:
            ## since we&#39;re deleting in a group this should be batched
            batch = generateUUID()
            
        for item in self:
            item.delete(disconnect=disconnect, batch=batch, setchange=setchange)
            
def _debug():
    ## Used to help debug 
    try:
        import wingdbstub
    except:
        pass    

# ===============================================================================
if __name__ == &#34;__main__&#34;:

    ## for debugging ...
    logging.info(&#34;Program started on %s&#34;, datetime.now().isoformat())</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="graphydb.FETCHKEYWORDS"><code class="name">var <span class="ident">FETCHKEYWORDS</span></code></dt>
<dd>
<div class="desc"><p>Keywords used in <code><a title="graphydb.Graph.fetch" href="#graphydb.Graph.fetch">Graph.fetch()</a></code>, everything else is a parameter.</p></div>
</dd>
<dt id="graphydb.RESERVED"><code class="name">var <span class="ident">RESERVED</span></code></dt>
<dd>
<div class="desc"><p>Reserved keyword that cannot be used in node and edge data.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="graphydb.cleandata"><code class="name flex">
<span>def <span class="ident">cleandata</span></span>(<span>fulldata)</span>
</code></dt>
<dd>
<div class="desc"><p>Return dict without keys that start with underscore (which are treated as temporary local variables).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleandata(fulldata):
    &#39;&#39;&#39;
    Return dict without keys that start with underscore (which are treated as temporary local variables).
    &#39;&#39;&#39;
    data = {k:v for k,v in fulldata.items() if k[0] != &#39;_&#39;}    
    return data</code></pre>
</details>
</dd>
<dt id="graphydb.conditionalyield"><code class="name flex">
<span>def <span class="ident">conditionalyield</span></span>(<span>keys, A, B)</span>
</code></dt>
<dd>
<div class="desc"><p>Iterator over values A[k] | B[k]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conditionalyield(keys,A,B):
    &#39;&#39;&#39;
    Iterator over values A[k] | B[k]
    &#39;&#39;&#39;
    for k in keys:
        yield (A[k] if k in A else B[k])</code></pre>
</details>
</dd>
<dt id="graphydb.diff"><code class="name flex">
<span>def <span class="ident">diff</span></span>(<span>d1, d2, changedkeys)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate a simple diff that takes dict d1 to d2.
Only keys in the set changedkeys are considered.
Keys starting with underscore are ignored.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diff(d1,d2,changedkeys):
    &#39;&#39;&#39;
    Calculate a simple diff that takes dict d1 to d2.
    Only keys in the set changedkeys are considered.
    Keys starting with underscore are ignored.
    &#39;&#39;&#39;
    remove = {}
    add = {}
    
    for k in d1.keys()|d2.keys():
        if k[0] == &#39;_&#39;:
            continue
        elif k in changedkeys:
            ## only consider keys explicitly marked as changed
            if k not in d2:
                remove[k] = d1[k]
            elif k not in d1:
                add[k] = d2[k]
            elif d1[k]!=d2[k]:
                ## only stored if values are actually different
                remove[k] = d1[k]
                add[k] = d2[k]
            
    if len(remove) == 1 and &#39;mtime&#39; in remove and len(add) == 1 and &#39;mtime&#39; in add:
        remove = {}
        add = {}
        
    change = {}
    if len(add)&gt;0:
        change[&#39;+&#39;] = add
    if len(remove)&gt;0:
        change[&#39;-&#39;] = remove
        
    return change</code></pre>
</details>
</dd>
<dt id="graphydb.ensurelist"><code class="name flex">
<span>def <span class="ident">ensurelist</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to ensure argument is a list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensurelist(x):
    &#39;&#39;&#39;
    Helper function to ensure argument is a list.
    &#39;&#39;&#39;
    if x is None:
        x = []
    elif type(x) != type([]):
        x = [x]
    return x</code></pre>
</details>
</dd>
<dt id="graphydb.generateUUID"><code class="name flex">
<span>def <span class="ident">generateUUID</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a random UUID.
Make as short as possible by encoding in all numbers and letters.
Sequence has to be case insensitive to support any filesystem and web.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generateUUID():
    &#39;&#39;&#39;
    Generate a random UUID.
    Make as short as possible by encoding in all numbers and letters.
    Sequence has to be case insensitive to support any filesystem and web.
    &#39;&#39;&#39;
    ## the standard uuid is 16 bytes. this has
    ## 256**16 = 340282366920938463463374607431768211456 possible values
    ## In hex with the alphabet &#39;0123456789abcdef&#39; this is
    ## 16**32 = 340282366920938463463374607431768211456
    ## encoding with the alphabet = &#39;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;
    ## can be done in 25 characters:
    ## 36**25 = 808281277464764060643139600456536293376
    ## keep case insensitive for robustness in URLS etc 
    ## (case sensitivity would only drop it to 22 characters)

    alphabet = &#39;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;
    N = len(alphabet)

    # emulate how uuid4 grabs entropy
    try:
        # first try to use the system urandom module if available
        # this should be more cryptographically secure than random
        rand = random.SystemRandom().random
        uu = &#39;&#39;.join([alphabet[(rand()*N).__int__()] for i in range(25)])
    except:
        # fall back on random
        rand = random.random
        uu = &#39;&#39;.join([alphabet[(rand()*N).__int__()] for i in range(25)])

    return uu</code></pre>
</details>
</dd>
<dt id="graphydb.jsonextract"><code class="name flex">
<span>def <span class="ident">jsonextract</span></span>(<span>param)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to wrap json extractions.</p>
<pre><code>e.g. &lt;code&gt;x.data.y&lt;/code&gt; becomes `json_extract(x.data, "$.y")`
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jsonextract(param):
    &#39;&#39;&#39;
    Helper function to wrap json extractions.
       
        e.g. `x.data.y` becomes `json_extract(x.data, &#34;$.y&#34;)`

    &#39;&#39;&#39;
    return re.sub(&#39;(\w+)\.data\.(\w+)&#39;,r&#39;json_extract(\1.data, &#34;$.\2&#34;)&#39;, param)</code></pre>
</details>
</dd>
<dt id="graphydb.patch"><code class="name flex">
<span>def <span class="ident">patch</span></span>(<span>d, change, reverse=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Patch a dict based on a change dict.
Return a patched shallow copy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def patch(d, change, reverse=False):
    &#39;&#39;&#39;
    Patch a dict based on a change dict.
    Return a patched shallow copy.
    &#39;&#39;&#39;
    d2=dict(d)
    if reverse:
        for k in change.get(&#39;+&#39;,{}).keys():
            del d2[k]
        d2.update(change.get(&#39;-&#39;,{}))
    else:
        for k in change.get(&#39;-&#39;,{}).keys():
            del d2[k]
        d2.update(change.get(&#39;+&#39;,{}))
    return d2</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="graphydb.ESet"><code class="flex name class">
<span>class <span class="ident">ESet</span></span>
<span>(</span><span>iterable=[])</span>
</code></dt>
<dd>
<div class="desc"><p>A set holding edges with some agregate functionality.</p>
<p>Takes an interable of objects with a <code>__uid__()</code> method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ESet(GraphyDBItemSet):
    &#39;&#39;&#39;
    A set holding edges with some agregate functionality.
    &#39;&#39;&#39;
    
    @property
    def end(self):
        &#39;&#39;&#39;
        The nodes at the ends of the edges in the set. Fetched from the database.
        &#39;&#39;&#39;
        out = NSet()
        for e in self:
            out.add(e.end)
        return out
    
    @property
    def start(self):
        &#39;&#39;&#39;
        The nodes at the start of the edges in the set. Fetched from the database.
        &#39;&#39;&#39;
        out = NSet()
        for e in self:
            out.add(e.start)
        return out

    def delete(self, batch=None, setchange=True):
        &#39;&#39;&#39;
        Delete the items from the *database*.
        N.B. don&#39;t confuse with remove() and discard() which work only on the set!
        &#39;&#39;&#39;
        if setchange and batch is None:
            ## since we&#39;re deleting in a group this should be batched
            batch = generateUUID()
            
        for item in self:
            item.delete(batch=batch, setchange=setchange)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="graphydb.GraphyDBItemSet" href="#graphydb.GraphyDBItemSet">GraphyDBItemSet</a></li>
<li><a title="graphydb.IndexedSet" href="#graphydb.IndexedSet">IndexedSet</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="graphydb.ESet.end"><code class="name">var <span class="ident">end</span></code></dt>
<dd>
<div class="desc"><p>The nodes at the ends of the edges in the set. Fetched from the database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def end(self):
    &#39;&#39;&#39;
    The nodes at the ends of the edges in the set. Fetched from the database.
    &#39;&#39;&#39;
    out = NSet()
    for e in self:
        out.add(e.end)
    return out</code></pre>
</details>
</dd>
<dt id="graphydb.ESet.start"><code class="name">var <span class="ident">start</span></code></dt>
<dd>
<div class="desc"><p>The nodes at the start of the edges in the set. Fetched from the database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def start(self):
    &#39;&#39;&#39;
    The nodes at the start of the edges in the set. Fetched from the database.
    &#39;&#39;&#39;
    out = NSet()
    for e in self:
        out.add(e.start)
    return out</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="graphydb.ESet.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, batch=None, setchange=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the items from the <em>database</em>.
N.B. don't confuse with remove() and discard() which work only on the set!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, batch=None, setchange=True):
    &#39;&#39;&#39;
    Delete the items from the *database*.
    N.B. don&#39;t confuse with remove() and discard() which work only on the set!
    &#39;&#39;&#39;
    if setchange and batch is None:
        ## since we&#39;re deleting in a group this should be batched
        batch = generateUUID()
        
    for item in self:
        item.delete(batch=batch, setchange=setchange)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="graphydb.GraphyDBItemSet" href="#graphydb.GraphyDBItemSet">GraphyDBItemSet</a></b></code>:
<ul class="hlist">
<li><code><a title="graphydb.GraphyDBItemSet.add" href="#graphydb.IndexedSet.add">add</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.append" href="#graphydb.IndexedSet.append">append</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.clear" href="#graphydb.IndexedSet.clear">clear</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.copy" href="#graphydb.IndexedSet.copy">copy</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.deletefts" href="#graphydb.GraphyDBItemSet.deletefts">deletefts</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.discard" href="#graphydb.IndexedSet.discard">discard</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.filter" href="#graphydb.GraphyDBItemSet.filter">filter</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.filter_fnmatch" href="#graphydb.GraphyDBItemSet.filter_fnmatch">filter_fnmatch</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.get" href="#graphydb.GraphyDBItemSet.get">get</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.getm" href="#graphydb.GraphyDBItemSet.getm">getm</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.one" href="#graphydb.GraphyDBItemSet.one">one</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.pop" href="#graphydb.IndexedSet.pop">pop</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.remove" href="#graphydb.IndexedSet.remove">remove</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.reverse" href="#graphydb.IndexedSet.reverse">reverse</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.save" href="#graphydb.GraphyDBItemSet.save">save</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.set" href="#graphydb.GraphyDBItemSet.set">set</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.setGraph" href="#graphydb.GraphyDBItemSet.setGraph">setGraph</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.sort" href="#graphydb.IndexedSet.sort">sort</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.update" href="#graphydb.IndexedSet.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="graphydb.Edge"><code class="flex name class">
<span>class <span class="ident">Edge</span></span>
<span>(</span><span>data, graph=None, changed=True)</span>
</code></dt>
<dd>
<div class="desc"><p>A Edge object
can contain abitrary key value pairs as long as they are JSONifiable </p>
<p>GraphyDBItem shoudn't be instantiated directly. Use <code><a title="graphydb.Node" href="#graphydb.Node">Node</a></code> or <code><a title="graphydb.Edge" href="#graphydb.Edge">Edge</a></code> instead.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Edge(GraphyDBItem):
    &#39;&#39;&#39;
    A Edge object
    can contain abitrary key value pairs as long as they are JSONifiable 
    &#39;&#39;&#39;
    
    _table = &#39;edges&#39;
    _ftstable = &#39;edgefts&#39;
    
    def __init__(self, data, graph=None, changed=True):
        
        if data.setdefault(&#39;kind&#39;, None) is None:
            raise GraphyDBException(&#34;Must supply edge kind&#34;)      
            
        if data.setdefault(&#39;startuid&#39;, None) is None:
            raise GraphyDBException(&#34;Wrong type or missing start node&#34;)

        if data.setdefault(&#39;enduid&#39;, None) is None:
            raise GraphyDBException(&#34;Wrong type or missing end node&#34;)

        super().__init__(data, graph=graph, changed=changed)
        
    def save(self, force=False, batch=None, setchange=True):
        &#39;&#39;&#39;
        Save the data to the database. Any keys that begin with &#34;_&#34; will *not* be saved.
        
        - `force`: if `True` will save regardless if item marked as changed.
        &#39;&#39;&#39;
        
        ## ignore if unforced and not dirty
        if not force and not self.changed:
            return self
        
        if not self.graph.exists(self[&#39;startuid&#39;]): 
            raise GraphyDBException(&#39;start node referenced from edge does not exist in DB.&#39;)
        if not self.graph.exists(self[&#39;enduid&#39;]):
            raise GraphyDBException(&#39;end node referenced from edge does not exist in DB.&#39;)
        
        data = cleandata(self.data)   
                
        if setchange:
            originalitem = self.original()                

        cursor = self.graph.cursor()
        cursor.execute(&#34;INSERT OR REPLACE INTO edges(uid, startuid, kind, enduid, ctime, mtime, data) VALUES(?,?,?,?,?,?,?)&#34;, 
                       (self[&#39;uid&#39;], self[&#39;startuid&#39;], self[&#39;kind&#39;], self[&#39;enduid&#39;], self[&#39;ctime&#39;], self[&#39;mtime&#39;], json.dumps(data)) )
        
        if setchange:
            self.graph.addchange(old=originalitem, new=self, batch=batch)                        
        
        self.setChanged(False)
        return self

            
    def delete(self, setchange=True, batch=None):
        &#39;&#39;&#39;
        Delete edge from database.
        &#39;&#39;&#39;
        cursor = self.graph.cursor()
        cursor.execute(&#39;DELETE FROM edges WHERE uid = ?&#39;, (self[&#39;uid&#39;],))
        self.deletefts()
        self[&#39;mtime&#39;] = time.time()
        
        if setchange:
            self.graph.addchange(old=self, batch=batch)
        
        self.setChanged(True)
        return self
            
    @property
    def start(self):
        &#39;&#39;&#39;
        Return node at start of directed edge
        &#39;&#39;&#39;
        return self.graph.fetch(CHAIN=&#39;(n)&#39;, WHERE=&#39;n.uid = :start_uid&#39;, start_uid=self[&#39;startuid&#39;]).pop()
    
    @property
    def end(self):
        &#39;&#39;&#39;
        Return node at end of directed edge
        &#39;&#39;&#39;
        return self.graph.fetch(CHAIN=&#39;(n)&#39;, WHERE=&#39;n.uid = :end_uid&#39;, end_uid=self[&#39;enduid&#39;]).pop()
    
    def __repr__(self):
        return &#39;({startuid})-[{uid}:{kind}]-&gt;({enduid})&#39;.format(**self.data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="graphydb.GraphyDBItem" href="#graphydb.GraphyDBItem">GraphyDBItem</a></li>
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="graphydb.Edge.end"><code class="name">var <span class="ident">end</span></code></dt>
<dd>
<div class="desc"><p>Return node at end of directed edge</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def end(self):
    &#39;&#39;&#39;
    Return node at end of directed edge
    &#39;&#39;&#39;
    return self.graph.fetch(CHAIN=&#39;(n)&#39;, WHERE=&#39;n.uid = :end_uid&#39;, end_uid=self[&#39;enduid&#39;]).pop()</code></pre>
</details>
</dd>
<dt id="graphydb.Edge.start"><code class="name">var <span class="ident">start</span></code></dt>
<dd>
<div class="desc"><p>Return node at start of directed edge</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def start(self):
    &#39;&#39;&#39;
    Return node at start of directed edge
    &#39;&#39;&#39;
    return self.graph.fetch(CHAIN=&#39;(n)&#39;, WHERE=&#39;n.uid = :start_uid&#39;, start_uid=self[&#39;startuid&#39;]).pop()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="graphydb.Edge.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, setchange=True, batch=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete edge from database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, setchange=True, batch=None):
    &#39;&#39;&#39;
    Delete edge from database.
    &#39;&#39;&#39;
    cursor = self.graph.cursor()
    cursor.execute(&#39;DELETE FROM edges WHERE uid = ?&#39;, (self[&#39;uid&#39;],))
    self.deletefts()
    self[&#39;mtime&#39;] = time.time()
    
    if setchange:
        self.graph.addchange(old=self, batch=batch)
    
    self.setChanged(True)
    return self</code></pre>
</details>
</dd>
<dt id="graphydb.Edge.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, force=False, batch=None, setchange=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the data to the database. Any keys that begin with "_" will <em>not</em> be saved.</p>
<ul>
<li><code>force</code>: if <code>True</code> will save regardless if item marked as changed.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, force=False, batch=None, setchange=True):
    &#39;&#39;&#39;
    Save the data to the database. Any keys that begin with &#34;_&#34; will *not* be saved.
    
    - `force`: if `True` will save regardless if item marked as changed.
    &#39;&#39;&#39;
    
    ## ignore if unforced and not dirty
    if not force and not self.changed:
        return self
    
    if not self.graph.exists(self[&#39;startuid&#39;]): 
        raise GraphyDBException(&#39;start node referenced from edge does not exist in DB.&#39;)
    if not self.graph.exists(self[&#39;enduid&#39;]):
        raise GraphyDBException(&#39;end node referenced from edge does not exist in DB.&#39;)
    
    data = cleandata(self.data)   
            
    if setchange:
        originalitem = self.original()                

    cursor = self.graph.cursor()
    cursor.execute(&#34;INSERT OR REPLACE INTO edges(uid, startuid, kind, enduid, ctime, mtime, data) VALUES(?,?,?,?,?,?,?)&#34;, 
                   (self[&#39;uid&#39;], self[&#39;startuid&#39;], self[&#39;kind&#39;], self[&#39;enduid&#39;], self[&#39;ctime&#39;], self[&#39;mtime&#39;], json.dumps(data)) )
    
    if setchange:
        self.graph.addchange(old=originalitem, new=self, batch=batch)                        
    
    self.setChanged(False)
    return self</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="graphydb.GraphyDBItem" href="#graphydb.GraphyDBItem">GraphyDBItem</a></b></code>:
<ul class="hlist">
<li><code><a title="graphydb.GraphyDBItem.changed" href="#graphydb.GraphyDBItem.changed">changed</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.data" href="#graphydb.GraphyDBItem.data">data</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.deletefts" href="#graphydb.GraphyDBItem.deletefts">deletefts</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.exists" href="#graphydb.GraphyDBItem.exists">exists</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.graph" href="#graphydb.GraphyDBItem.graph">graph</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.original" href="#graphydb.GraphyDBItem.original">original</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.renew" href="#graphydb.GraphyDBItem.renew">renew</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.set" href="#graphydb.GraphyDBItem.set">set</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.setChanged" href="#graphydb.GraphyDBItem.setChanged">setChanged</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.setGraph" href="#graphydb.GraphyDBItem.setGraph">setGraph</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.updatefts" href="#graphydb.GraphyDBItem.updatefts">updatefts</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="graphydb.Graph"><code class="flex name class">
<span>class <span class="ident">Graph</span></span>
<span>(</span><span>path=':memory:')</span>
</code></dt>
<dd>
<div class="desc"><p>A graph composed of nodes and edges, both stored in SQLite database.</p>
<p>Instantiating it without argument creates an in-memory database,
pass in a path to create or open a database in a file</p>
<pre><code>memdb = Graph()

filedb = Graph(path)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Graph:
    &#39;&#39;&#39;
    A graph composed of nodes and edges, both stored in SQLite database.
    &#39;&#39;&#39;
    def __init__(self, path=&#39;:memory:&#39;):
        &#39;&#39;&#39;
        Instantiating it without argument creates an in-memory database, 
        pass in a path to create or open a database in a file
    
            memdb = Graph()
       
            filedb = Graph(path)
        &#39;&#39;&#39;
        self.path = path
        if os.path.exists(path):
            ## connect to existing database
            self.connection = apsw.Connection(self.path)
        else:
            ## create new database and set up tables
            self.connection = apsw.Connection(self.path)
            self.reset() 
            self.resetfts()
        
    def reset(self):
        &#39;&#39;&#39;
        Drop the tables and recreate them.
        *All data will be lost!*
        &#39;&#39;&#39;
        cursor=self.cursor()
                  
        cursor.execute(&#39;&#39;&#39;
            DROP TABLE IF EXISTS nodes;
            DROP TABLE IF EXISTS edges;
            DROP TABLE IF EXISTS settings;
            DROP TABLE IF EXISTS cache;
            DROP TABLE IF EXISTS changes;
            CREATE TABLE IF NOT EXISTS nodes(uid TEXT PRIMARY KEY, kind TEXT, ctime REAL, mtime REAL, data TEXT);
            CREATE TABLE IF NOT EXISTS edges(uid TEXT PRIMARY KEY, kind TEXT, startuid TEXT NOT NULL REFERENCES nodes(uid), enduid TEXT NOT NULL REFERENCES nodes(uid), ctime REAL, mtime REAL, data TEXT);
            CREATE TABLE IF NOT EXISTS settings(key TEXT PRIMARY KEY, value TEXT);
            CREATE TABLE IF NOT EXISTS cache(key TEXT PRIMARY KEY, value TEXT);
            CREATE TABLE IF NOT EXISTS changes(id INTEGER PRIMARY KEY AUTOINCREMENT, change TEXT);
        &#39;&#39;&#39;)
        
        ## store GraphyDB version that was used to create the database
        self.savesetting(&#39;GraphyDB version&#39;, __version__)

    def countchanges(self):
        cursor=self.cursor()
        n=cursor.execute(&#39;SELECT COUNT(*) FROM changes&#39;).fetchone()[0]
        return n
    
    def clearchanges(self):
        ## recreate table so it resets the IDs
        cursor=self.cursor()
        cursor.execute(&#39;&#39;&#39;
        DROP TABLE IF EXISTS changes;
        CREATE TABLE changes(id INTEGER PRIMARY KEY AUTOINCREMENT, change TEXT);
        &#39;&#39;&#39;)        
    
    def lastchanges(self):
        if self.countchanges()==0:
            ## no changes
            out = []
        else:
            cursor=self.cursor()
            cid, change = cursor.execute(&#39;&#39;&#39;
                SELECT id, change FROM changes
                ORDER BY id DESC LIMIT 1
                &#39;&#39;&#39;).fetchone()
            change = json.loads(change)
            if &#39;batch&#39; not in change:
                ## single change item
                out = [(cid, change)]
            else:
                ## possibly multiple change items in same batch
                rows = cursor.execute(&#39;&#39;&#39;
                    SELECT id, change FROM changes
                    WHERE json_extract(change, &#34;$.batch&#34;) = ? ORDER BY id&#39;&#39;&#39;, [change[&#39;batch&#39;]]).fetchall()   
                out = [(cid, json.loads(change)) for cid, change in rows]
                
        return out
    
    def deletechange(self, id):
        cursor=self.cursor()
        cursor.execute(&#39;DELETE FROM changes WHERE id = ?&#39;, [id])
        
    def addchange(self, new=None, old=None, batch=None):
        
        if new is None and old is None:
            return
            
        change = {}
        if new is None:
            ## this is a delete
            change[&#39;uid&#39;] = old[&#39;uid&#39;]
            change[&#39;-&#39;] = cleandata(old.data)
        elif old is None:
            ## this is add
            change[&#39;uid&#39;] = new[&#39;uid&#39;]
            change[&#39;+&#39;] = cleandata(new.data)
        else:
            ## item internals have changed
            change[&#39;uid&#39;] = new[&#39;uid&#39;]
            change.update(diff(old.data, new.data, new._changedkeys))
        
        change.setdefault(&#39;time&#39;, time.time())
        change.setdefault(&#39;rev&#39;, generateUUID())
        if batch is not None:
            change[&#39;batch&#39;] = batch
            
        change = json.dumps(change)
            
        cursor=self.cursor()
        row=cursor.execute(&#39;&#39;&#39;INSERT INTO changes (change) VALUES (?)&#39;&#39;&#39;, [change])

    def undo(self):
        &#39;&#39;&#39;
        Undo the last change to the graph.
        &#39;&#39;&#39;
        changes = []
        changebatch=reversed(self.lastchanges())
        for i, change in changebatch:
            if &#39;+&#39; in change and &#39;-&#39; not in change:
                ## change was to add item so undo removes it
                action = &#34;-&#34;
                item = self.getuid(change[&#39;uid&#39;])
                item.delete(setchange=False) 
            elif &#39;-&#39; in change and &#39;+&#39; not in change:
                ## change was to remove item so undo adds it
                action = &#34;+&#34;
                data = change[&#39;-&#39;]
                if &#39;startuid&#39; in data:
                    item = Edge(data, graph=self)
                else:
                    item = Node(data, graph=self)
                item.save(setchange=False)
            elif &#39;-&#39; in change and &#39;+&#39; in change:
                ## change was to add and remove internals so undo reverses them
                action = &#34;*&#34;
                item = self.getuid(change[&#39;uid&#39;])
                item.data = patch(item.data, change, reverse=True)
                item.save(setchange=False, force=True)
            else:
                raise GraphyDBException(&#39;Unknown undo action&#39;)
            changes.append((action, change[&#39;uid&#39;]))
            self.deletechange(i)
        return changes

    def resetfts(self, nodefields=None, edgefields=None):
                
        ## remove tables
        cursor=self.cursor()
        cursor.execute(&#39;&#39;&#39;
            DROP TABLE IF EXISTS nodefts;
            DROP TABLE IF EXISTS edgefts;
        &#39;&#39;&#39;) 
        
        ## create node table
        if nodefields is not None:
            nodefields = set(nodefields)
            VSTR = &#34;,&#34;.join(nodefields) + &#34;,uid UNINDEXED&#34;
            cursor.execute(&#39;CREATE VIRTUAL TABLE IF NOT EXISTS nodefts USING fts5({});&#39;.format(VSTR))
            
            
        ## create edge table
        if edgefields is not None:
            edgefields = set(edgefields)
            ESTR = &#34;,&#34;.join(edgefields)+&#34;,uid UNINDEXED&#34;
            cursor.execute(&#39;CREATE VIRTUAL TABLE IF NOT EXISTS edgefts USING fts5({});&#39;.format(ESTR))
        
    def getsetting(self, key):
        &#39;&#39;&#39;
        Read back a previously saved setting. Value will be de-jsonified.
        &#39;&#39;&#39;
        cursor=self.cursor()
        row = cursor.execute(&#39;SELECT value FROM settings WHERE key = ?&#39;,[key]).fetchone()
        if row is None:
            raise KeyError
        
        value = json.loads(row[0])
        return value
        
    def savesetting(self, key, value):
        &#39;&#39;&#39;
        A simple key-value store to save settings. Values will be jsonified.
        &#39;&#39;&#39;
        cursor=self.cursor()
        settings = cursor.execute(&#39;INSERT OR REPLACE INTO settings(key, value) VALUES(?,?)&#39;, (key, json.dumps(value)) )

    def cached(self, key):
        &#39;&#39;&#39;
        Read back a previously cached item. Value will be de-jsonified.
        &#39;&#39;&#39;
        cursor=self.cursor()
        row = cursor.execute(&#39;SELECT value FROM cache WHERE key = ?&#39;,[key]).fetchone()
        if row is None:
            raise KeyError
        return json.loads(row[0])
        
    def cache(self, key, value):
        &#39;&#39;&#39;
        A simple key-value store to serve as a cache. Values will be stored jsonified under the given key.
        &#39;&#39;&#39;
        cursor=self.cursor()
        settings = cursor.execute(&#39;INSERT OR REPLACE INTO cache(key, value) VALUES(?,?)&#39;, (key, json.dumps(value)) )

    def cursor(self):
        &#39;&#39;&#39;
        Return an APSW cursor.
        
        This can be used to excute SQL queries directly on the database.
        &#39;&#39;&#39;
        return self.connection.cursor()
    
    @property
    def stats(self):
        &#39;&#39;&#39;
        Return basic stats of the graph such as the number of edges and nodes.
        &#39;&#39;&#39;
        cursor=self.cursor()
        Nn = cursor.execute(&#39;SELECT COUNT(*) FROM nodes&#39;).fetchone()[0]
        Ne = cursor.execute(&#39;SELECT COUNT(*) FROM edges&#39;).fetchone()[0]
        
        nkinds = {}
        for k,n in cursor.execute(&#39;SELECT kind, COUNT(kind) FROM nodes GROUP BY kind&#39;):
            nkinds[k]=n
        ekinds = {}
        for k,n in cursor.execute(&#39;SELECT kind, COUNT(kind) FROM edges GROUP BY kind&#39;):
            ekinds[k]=n
        
        S = {&#34;Total nodes&#34;:Nn, &#34;Total edges&#34;:Ne, &#34;Node kinds&#34;:nkinds, &#34;Edge kinds&#34;:ekinds}
        
        if self.path!=&#39;:memory:&#39;:
            stat = os.stat(self.path)
            size = stat.st_size
            if size &lt; 1000:
                sizestr = &#34;%dB&#34;%size
            elif size &lt; 1000000:
                sizestr = &#34;%dK&#34;%(size/1000)
            else:
                sizestr = &#34;%dM&#34;%(size/1000000)
            S[&#39;File size&#39;]= sizestr
            
        sversion = cursor.execute(&#39;SELECT sqlite_version()&#39;).fetchone()[0] 
        S[&#39;SQLite version&#39;] = sversion
        S[&#39;GraphyDB version&#39;] = self.getsetting(&#39;GraphyDB version&#39;)
        
        S[&#39;Changes&#39;] = self.countchanges()
        
        return S

    def _parsechain(self, CHAIN, PARAM):
        &#39;&#39;&#39;
        Break down the chain of edges and nodes.
        &#39;&#39;&#39;
            
        aliases = {}
        collect = None
        left = None
        search1 = re.compile(&#39;\(([\w:]+)\)&#39;)
        search2 = re.compile(&#39;\[([\w:,]+)\]&#39;)
        for p in CHAIN.split():
            ## parse kind of item
            if p[-1] == &#39;&gt;&#39;:
                item = {&#39;type&#39;:&#39;right&#39;,&#39;table&#39;:&#39;edges&#39;,&#39;leftuid&#39;:&#39;startuid&#39;,&#39;rightuid&#39;:&#39;enduid&#39;,&#39;ftstable&#39;:&#39;edgefts&#39;,&#39;columns&#39;:[&#39;data&#39;]}
            elif p[0] == &#39;&lt;&#39;:
                item = {&#39;type&#39;:&#39;left&#39;,&#39;table&#39;:&#39;edges&#39;,&#39;leftuid&#39;:&#39;enduid&#39;,&#39;rightuid&#39;:&#39;startuid&#39;,&#39;ftstable&#39;:&#39;edgefts&#39;,&#39;columns&#39;:[&#39;data&#39;]}
            else:
                item = {&#39;type&#39;:&#39;node&#39;,&#39;table&#39;:&#39;nodes&#39;,&#39;leftuid&#39;:&#39;uid&#39;,&#39;rightuid&#39;:&#39;uid&#39;,&#39;ftstable&#39;:&#39;nodefts&#39;,&#39;columns&#39;:[&#39;data&#39;]}
                
            ## parse aliases, extra parameters and kinds
            so1=search1.search(p)
            so2=search2.search(p)
            if so1:
                tmp = so1.group(1).split(&#39;:&#39;)
                alias=tmp[0]
                if len(tmp)==2:
                    item[&#34;kind&#34;]=tmp[1]
    
            elif so2:
                s = so2.group(1).split(&#34;,&#34;)
                tmp = s[0].split(&#39;:&#39;)
                alias=tmp[0]     
                collect = item
                if len(s)&gt;1:
                    item[&#39;extra&#39;] = {}
                    for c in s[1:]:
                        try:
                            col = &#39;{} AS &#34;{}&#34;&#39;.format(PARAM[c],c)
                        except KeyError:
                            raise GraphyDBException(&#39;Item &#34;{}&#34; not given an expansion&#39;.format(c))
                        item[&#39;extra&#39;][c]=col
                        ## remove these extra columns from parameters
                        del PARAM[c]
                if len(tmp)==2:
                    item[&#34;kind&#34;]=tmp[1]

            else:
                raise GraphyDBException(&#34;Error in parsing format: &#39;{}&#39;&#34;.format(p) )
            
            if alias in aliases:
                raise GraphyDBException(&#34;Aliases must be unique ({} multiply defined)&#34;.format(alias) )
            
            
            item[&#39;alias&#39;] = alias
            
            ## link
            if left is not None:
                item[&#39;leftlink&#39;] = left[&#39;alias&#39;]
                left[&#39;rightlink&#39;] = item[&#39;alias&#39;]   
                
            aliases[alias]=item
            left = item
        
        if collect is None:
            collect = item
    
        return aliases, collect
    
    def fetch(self, CHAIN=&#39;(n)&#39;, WHERE=None, **args):
        &#39;&#39;&#39;
        This is the workhorse for fetching nodes and edges from the database. It&#39;s a thin wrapper around
        SQL so most of the SQL operators are available.
        
        **Keywords**
        
        - `CHAIN`: Description of how to join together nodes and edges for the query. 
                   A chain is composed of links read from left to right separated by spaces. 
                   Each link can be a node &#34;(n)&#34; or and edge &#34;-(e)&gt;&#34; or &#34;&lt;(e)-&#34;. 
                   e.g. &#34;(n1) -[e:Document,title]&gt; (n2)&#34;.
                   The variable in the brackets is an alias for the link that can then be used 
                   in other parts of the query and should be unique. 
                   Square brackets indicate the link to be collected (otherwise defaults to right-most link).
                   Square brackets can also have other aliases separated by commas, these should be defined in parameters passed
                   to the function.
        - `WHERE`: A string, or list of strings with SQL conditions. If it&#39;s a list the items will be ANDed together
        - `GROUP`: String to follow SQLs GROUP BY
        - `ORDER`: String to follow SQLs ORDER BY
        - `LIMIT`: An interger to limit the numer of items returned
        - `OFFSET`: Return items from offset, used in combination with `LIMIT`
        - `COUNT`: The number of items satisfying the query will be returned
        - `DISTINCT`: Distinct uids will be collected. [Defaults to `True`]
        - `DEBUG`: If this is set to `True` the generated SQL and parameters will be returned without making the query.
        
        For convenience `CHAIN` and `WHERE` are the first two implicit parameters.
        
        **Parameters**
        
        Every other keyword is treated as a parameter for defining returned values, FTS searches or SQL escaped parameters. 
        
        Any extra aliases in the collected item should be defined as a parameter. The result will be available as a key 
        in the item with the alias preceded by an underscore (i.e. an unsaved value). 
        
        If a parameter is the same as a link-alias with &#34;_fts&#34; appended then the value is to be
        used in an FTS match. 
        
        Values to be SQL escaped whould be inserted by name (e.g. &#39;:p1&#39;) where appropriate and the value given by a parameter
        (e.g. p1=10).
        
        **Example**
        
            # Fetch the nodes of kind &#34;Person&#34; that are  
            # connected by edges of kind &#34;Author&#34; to other 
            # nodes of kind &#34;Document&#34; with tiles containing &#34;Quantum&#34;
            # and also collect the author order
            g.fetch(&#39;(n:Document) &lt;(e:Author)- [p:Person,aorder]&#39;, n_fts=&#39;title: Quantum&#39;, aorder=&#39;e.data.order&#39;)
        &#39;&#39;&#39;
        
        ## extract the SQL pieces with sensible defaults
        WHERE=ensurelist(WHERE)
        ORDER=args.get(&#39;ORDER&#39;, None)
        GROUP=args.get(&#39;GROUP&#39;, None)
        LIMIT=args.get(&#39;LIMIT&#39;, None)
        OFFSET=args.get(&#39;OFFSET&#39;, None)
        COUNT=args.get(&#39;COUNT&#39;, False)
        DISTINCT=args.get(&#39;DISTINCT&#39;, True)    
        DEBUG=args.get(&#39;DEBUG&#39;, False)

        ## everything else is a parameter of some sort
        PARAM = {k:v for k,v in args.items() if k not in FETCHKEYWORDS}
                    
        ## interpret table joins
        aliases, collect = self._parsechain(CHAIN, PARAM)
            
        SQL = []

        SQLFTS = []
        ## SQL to attach FTS tables ... need to do this fist so we can expand fts aliases with tablename
        ftsexpansions = {}
        for k in aliases.keys():
            ftskey = k+&#39;_fts&#39;
            if ftskey in list(PARAM.keys()):
                ## N.B. want a copy of PARAM.keys() as we might modify PARAM
                item = aliases[k]
                SQLFTS.append(&#39;\nJOIN {ftstable} &#34;{ftskey}&#34; ON {alias}.uid = {ftskey}.uid&#39;.format(
                    ftstable=item[&#39;ftstable&#39;], ftskey=ftskey, alias=k))
                ## add an item to PARAM with the FTS term so it&#39;s SQL escaped
                valuekey = ftskey+&#39;_value&#39;
                ## N.B. proper reference using alias has to have table name, e.g. n1_fts.nodefts
                WHERE.append(&#39;{ftskey}.{ftstable} MATCH :{ftsvalue}&#39;.format(
                    ftskey=ftskey, ftstable=aliases[k][&#39;ftstable&#39;], ftsvalue=valuekey))
                PARAM[valuekey] = PARAM[ftskey]
                del PARAM[ftskey]
                ftsexpansions[ftskey] = &#34;{}.{}&#34;.format(ftskey,aliases[k][&#39;ftstable&#39;])
            
        def expandfts(ftsstring, ftsexpansions):
            for ftskey, ftsexpanded in ftsexpansions.items():
                ftsstring = ftsstring.replace(ftskey, ftsexpanded)
            return ftsstring
            
        ##
        ## SELECT
        ##
        collect[&#39;distinct&#39;] = &#39;DISTINCT&#39; if DISTINCT else &#39;&#39;
        colkeys = collect[&#39;columns&#39;].copy()
        colsql = [&#39;{}.{}&#39;.format(collect[&#39;alias&#39;],c) for c in colkeys]
        for k,v in collect.get(&#39;extra&#39;,{}).items():
            colkeys.append(k)
            v = jsonextract(v)
            v = expandfts(v, ftsexpansions)
            colsql.append(v)

        collect[&#39;collectcolumns&#39;] = &#39;, &#39;.join(colsql)
        if COUNT:
            SQL.append(&#39;SELECT COUNT({distinct} {alias}.uid) FROM {table} {alias}&#39;.format(**collect))
        else:
            SQL.append(&#39;SELECT {distinct} {collectcolumns} FROM {table} {alias}&#39;.format(**collect))
    
        
        ##
        ## JOINs
        ##
        ## link tables together
        l = collect        
        while &#39;rightlink&#39; in l:
            r = aliases[l[&#39;rightlink&#39;]]
            r[&#39;join&#39;] = &#39;{}.{} = {}.{}&#39;.format(r[&#39;alias&#39;], r[&#39;leftuid&#39;], l[&#39;alias&#39;], l[&#39;rightuid&#39;])
            if &#39;kind&#39; in r:
                r[&#39;join&#39;] += &#39; AND {}.kind = &#34;{}&#34;&#39;.format(r[&#39;alias&#39;],r[&#39;kind&#39;])
            SQL.append(&#39;\nJOIN {table} {alias} ON {join}&#39;.format(**r))
            l=r
        r = collect
        while &#39;leftlink&#39; in r:
            l = aliases[r[&#39;leftlink&#39;]]
            l[&#39;join&#39;] = &#39;{}.{} = {}.{}&#39;.format(l[&#39;alias&#39;], l[&#39;rightuid&#39;], r[&#39;alias&#39;], r[&#39;leftuid&#39;] )  
            if &#39;kind&#39; in l:
                l[&#39;join&#39;] += &#39; AND {alias}.kind = &#34;{kind}&#34;&#39;.format(**l)
            SQL.append(&#39;\nJOIN {table} {alias} ON {join}&#39;.format(**l))
            r=l
    
        SQL.extend(SQLFTS)
        
        ##
        ## WHERE
        ##
        if &#39;kind&#39; in collect:
            WHERE.append(&#39;{alias}.kind = &#34;{kind}&#34;&#39;.format(**collect))

        if len(WHERE)&gt;0:
            SQL.append(&#39;\nWHERE &#39;+ &#39; AND &#39;.join([jsonextract(w) for w in WHERE]))
        

        ##
        ## GROUP BY
        ##
        if GROUP is not None:
            SQL.append(&#39;\nGROUP BY {}&#39;.format(expandfts(jsonextract(GROUP), ftsexpansions)))
        
        ##
        ## ORDER BY
        ##
        if ORDER is not None:
            SQL.append(&#39;\nORDER BY {}&#39;.format(expandfts(jsonextract(ORDER),ftsexpansions)))
        
            
        ##
        ## LIMIT and OFFSET
        ##
        if LIMIT is not None:
            SQL.append(&#39;\nLIMIT {}&#39;.format(LIMIT))
        if OFFSET is not None:
            SQL.append(&#39; OFFSET {}&#39;.format(OFFSET))
    
        SQL = &#39;&#39;.join(SQL)
        ##
        ## Return sql statement if debug
        ##
        if DEBUG:
            return SQL, PARAM
        
        cursor=self.cursor()
            
        ## faster to first create list
        items = []
        
        ##
        ## COUNT
        ##
        if COUNT:
            c = cursor.execute(SQL, PARAM).fetchone()[0]
            return c
        
        ##
        ## COLLECT
        ##        
        elif collect[&#39;type&#39;]==&#39;node&#39;:
            for row in cursor.execute(SQL, PARAM):
                args = json.loads(row[colkeys.index(&#39;data&#39;)])
                for c,v in zip(colkeys, row):
                    if c == &#39;data&#39;:
                        continue                        
                    else:
                        args[&#39;_&#39;+c] = v
                N = Node(args, graph=self, changed=False)
                items.append(N)
            return NSet(items)
        
        else:
            for row in cursor.execute(SQL, PARAM):
                args = json.loads(row[colkeys.index(&#39;data&#39;)])
                for c,v in zip(colkeys, row):
                    if c == &#39;data&#39;:
                        continue                        
                    else:
                        args[&#39;_&#39;+c] = v
                E = Edge(args, graph=self, changed=False)
                items.append(E)
            return ESet(items)

    def exists(self, uid):
        &#39;&#39;&#39;
        Return if item exists in the database as a node or edge. UIDs are big and bad enough that they should be
        unique across all intances of nodes and edges.
        &#39;&#39;&#39;
        cursor = self.cursor()
        n = cursor.execute(&#39;SELECT COUNT(*) FROM nodes WHERE uid = ?&#39;,[uid]).fetchone()[0]
        if n==1:
            return True
        else:
            n = cursor.execute(&#39;SELECT COUNT(*) FROM edges WHERE uid = ?&#39;,[uid]).fetchone()[0]
            if n==1:
                return True      
            else:
                return False 

    def getuid(self, uid):
        &#39;&#39;&#39;
        Convenience function to find either a node or edge with a given uid.
        &#39;&#39;&#39;
        
        obj = self.fetch(CHAIN=&#39;(n)&#39;, WHERE=&#39;n.uid = :uid&#39;, uid=uid).one
        if obj is None:
            obj = self.fetch(CHAIN=&#39;-(e)&gt;&#39;, WHERE=&#39;e.uid = :uid&#39;, uid=uid).one
            
        return obj
    
    def Node(self, kind=None, **args):
        &#39;&#39;&#39;
        Convenience method to create a new `graphydb.Node` and linked to the database.
        &#39;&#39;&#39;
        args[&#39;kind&#39;] = kind
        return Node(args, graph=self)
    
    def Edge(self, startuid=None, kind=None, enduid=None, **args):
        &#39;&#39;&#39;
        Convenience method to create a new `graphydb.Edge` linked to the database.
        &#39;&#39;&#39;
        
        if isinstance(startuid, Node):
            startuid = startuid[&#39;uid&#39;]
        if isinstance(enduid, Node):
            enduid = enduid[&#39;uid&#39;]  
        args.update({&#39;kind&#39;:kind,&#39;startuid&#39;:startuid, &#39;enduid&#39;:enduid })
            
        return Edge(args, graph=self)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="graphydb.Graph.stats"><code class="name">var <span class="ident">stats</span></code></dt>
<dd>
<div class="desc"><p>Return basic stats of the graph such as the number of edges and nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stats(self):
    &#39;&#39;&#39;
    Return basic stats of the graph such as the number of edges and nodes.
    &#39;&#39;&#39;
    cursor=self.cursor()
    Nn = cursor.execute(&#39;SELECT COUNT(*) FROM nodes&#39;).fetchone()[0]
    Ne = cursor.execute(&#39;SELECT COUNT(*) FROM edges&#39;).fetchone()[0]
    
    nkinds = {}
    for k,n in cursor.execute(&#39;SELECT kind, COUNT(kind) FROM nodes GROUP BY kind&#39;):
        nkinds[k]=n
    ekinds = {}
    for k,n in cursor.execute(&#39;SELECT kind, COUNT(kind) FROM edges GROUP BY kind&#39;):
        ekinds[k]=n
    
    S = {&#34;Total nodes&#34;:Nn, &#34;Total edges&#34;:Ne, &#34;Node kinds&#34;:nkinds, &#34;Edge kinds&#34;:ekinds}
    
    if self.path!=&#39;:memory:&#39;:
        stat = os.stat(self.path)
        size = stat.st_size
        if size &lt; 1000:
            sizestr = &#34;%dB&#34;%size
        elif size &lt; 1000000:
            sizestr = &#34;%dK&#34;%(size/1000)
        else:
            sizestr = &#34;%dM&#34;%(size/1000000)
        S[&#39;File size&#39;]= sizestr
        
    sversion = cursor.execute(&#39;SELECT sqlite_version()&#39;).fetchone()[0] 
    S[&#39;SQLite version&#39;] = sversion
    S[&#39;GraphyDB version&#39;] = self.getsetting(&#39;GraphyDB version&#39;)
    
    S[&#39;Changes&#39;] = self.countchanges()
    
    return S</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="graphydb.Graph.Edge"><code class="name flex">
<span>def <span class="ident">Edge</span></span>(<span>self, startuid=None, kind=None, enduid=None, **args)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience method to create a new <code><a title="graphydb.Edge" href="#graphydb.Edge">Edge</a></code> linked to the database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Edge(self, startuid=None, kind=None, enduid=None, **args):
    &#39;&#39;&#39;
    Convenience method to create a new `graphydb.Edge` linked to the database.
    &#39;&#39;&#39;
    
    if isinstance(startuid, Node):
        startuid = startuid[&#39;uid&#39;]
    if isinstance(enduid, Node):
        enduid = enduid[&#39;uid&#39;]  
    args.update({&#39;kind&#39;:kind,&#39;startuid&#39;:startuid, &#39;enduid&#39;:enduid })
        
    return Edge(args, graph=self)</code></pre>
</details>
</dd>
<dt id="graphydb.Graph.Node"><code class="name flex">
<span>def <span class="ident">Node</span></span>(<span>self, kind=None, **args)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience method to create a new <code><a title="graphydb.Node" href="#graphydb.Node">Node</a></code> and linked to the database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Node(self, kind=None, **args):
    &#39;&#39;&#39;
    Convenience method to create a new `graphydb.Node` and linked to the database.
    &#39;&#39;&#39;
    args[&#39;kind&#39;] = kind
    return Node(args, graph=self)</code></pre>
</details>
</dd>
<dt id="graphydb.Graph.addchange"><code class="name flex">
<span>def <span class="ident">addchange</span></span>(<span>self, new=None, old=None, batch=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addchange(self, new=None, old=None, batch=None):
    
    if new is None and old is None:
        return
        
    change = {}
    if new is None:
        ## this is a delete
        change[&#39;uid&#39;] = old[&#39;uid&#39;]
        change[&#39;-&#39;] = cleandata(old.data)
    elif old is None:
        ## this is add
        change[&#39;uid&#39;] = new[&#39;uid&#39;]
        change[&#39;+&#39;] = cleandata(new.data)
    else:
        ## item internals have changed
        change[&#39;uid&#39;] = new[&#39;uid&#39;]
        change.update(diff(old.data, new.data, new._changedkeys))
    
    change.setdefault(&#39;time&#39;, time.time())
    change.setdefault(&#39;rev&#39;, generateUUID())
    if batch is not None:
        change[&#39;batch&#39;] = batch
        
    change = json.dumps(change)
        
    cursor=self.cursor()
    row=cursor.execute(&#39;&#39;&#39;INSERT INTO changes (change) VALUES (?)&#39;&#39;&#39;, [change])</code></pre>
</details>
</dd>
<dt id="graphydb.Graph.cache"><code class="name flex">
<span>def <span class="ident">cache</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<div class="desc"><p>A simple key-value store to serve as a cache. Values will be stored jsonified under the given key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cache(self, key, value):
    &#39;&#39;&#39;
    A simple key-value store to serve as a cache. Values will be stored jsonified under the given key.
    &#39;&#39;&#39;
    cursor=self.cursor()
    settings = cursor.execute(&#39;INSERT OR REPLACE INTO cache(key, value) VALUES(?,?)&#39;, (key, json.dumps(value)) )</code></pre>
</details>
</dd>
<dt id="graphydb.Graph.cached"><code class="name flex">
<span>def <span class="ident">cached</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Read back a previously cached item. Value will be de-jsonified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cached(self, key):
    &#39;&#39;&#39;
    Read back a previously cached item. Value will be de-jsonified.
    &#39;&#39;&#39;
    cursor=self.cursor()
    row = cursor.execute(&#39;SELECT value FROM cache WHERE key = ?&#39;,[key]).fetchone()
    if row is None:
        raise KeyError
    return json.loads(row[0])</code></pre>
</details>
</dd>
<dt id="graphydb.Graph.clearchanges"><code class="name flex">
<span>def <span class="ident">clearchanges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clearchanges(self):
    ## recreate table so it resets the IDs
    cursor=self.cursor()
    cursor.execute(&#39;&#39;&#39;
    DROP TABLE IF EXISTS changes;
    CREATE TABLE changes(id INTEGER PRIMARY KEY AUTOINCREMENT, change TEXT);
    &#39;&#39;&#39;)        </code></pre>
</details>
</dd>
<dt id="graphydb.Graph.countchanges"><code class="name flex">
<span>def <span class="ident">countchanges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def countchanges(self):
    cursor=self.cursor()
    n=cursor.execute(&#39;SELECT COUNT(*) FROM changes&#39;).fetchone()[0]
    return n</code></pre>
</details>
</dd>
<dt id="graphydb.Graph.cursor"><code class="name flex">
<span>def <span class="ident">cursor</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return an APSW cursor.</p>
<p>This can be used to excute SQL queries directly on the database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cursor(self):
    &#39;&#39;&#39;
    Return an APSW cursor.
    
    This can be used to excute SQL queries directly on the database.
    &#39;&#39;&#39;
    return self.connection.cursor()</code></pre>
</details>
</dd>
<dt id="graphydb.Graph.deletechange"><code class="name flex">
<span>def <span class="ident">deletechange</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deletechange(self, id):
    cursor=self.cursor()
    cursor.execute(&#39;DELETE FROM changes WHERE id = ?&#39;, [id])</code></pre>
</details>
</dd>
<dt id="graphydb.Graph.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>self, uid)</span>
</code></dt>
<dd>
<div class="desc"><p>Return if item exists in the database as a node or edge. UIDs are big and bad enough that they should be
unique across all intances of nodes and edges.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exists(self, uid):
    &#39;&#39;&#39;
    Return if item exists in the database as a node or edge. UIDs are big and bad enough that they should be
    unique across all intances of nodes and edges.
    &#39;&#39;&#39;
    cursor = self.cursor()
    n = cursor.execute(&#39;SELECT COUNT(*) FROM nodes WHERE uid = ?&#39;,[uid]).fetchone()[0]
    if n==1:
        return True
    else:
        n = cursor.execute(&#39;SELECT COUNT(*) FROM edges WHERE uid = ?&#39;,[uid]).fetchone()[0]
        if n==1:
            return True      
        else:
            return False </code></pre>
</details>
</dd>
<dt id="graphydb.Graph.fetch"><code class="name flex">
<span>def <span class="ident">fetch</span></span>(<span>self, CHAIN='(n)', WHERE=None, **args)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the workhorse for fetching nodes and edges from the database. It's a thin wrapper around
SQL so most of the SQL operators are available.</p>
<p><strong>Keywords</strong></p>
<ul>
<li><code>CHAIN</code>: Description of how to join together nodes and edges for the query.
A chain is composed of links read from left to right separated by spaces.
Each link can be a node "(n)" or and edge "-(e)&gt;" or "&lt;(e)-".
e.g. "(n1) -[e:Document,title]&gt; (n2)".
The variable in the brackets is an alias for the link that can then be used
in other parts of the query and should be unique.
Square brackets indicate the link to be collected (otherwise defaults to right-most link).
Square brackets can also have other aliases separated by commas, these should be defined in parameters passed
to the function.</li>
<li><code>WHERE</code>: A string, or list of strings with SQL conditions. If it's a list the items will be ANDed together</li>
<li><code>GROUP</code>: String to follow SQLs GROUP BY</li>
<li><code>ORDER</code>: String to follow SQLs ORDER BY</li>
<li><code>LIMIT</code>: An interger to limit the numer of items returned</li>
<li><code>OFFSET</code>: Return items from offset, used in combination with <code>LIMIT</code></li>
<li><code>COUNT</code>: The number of items satisfying the query will be returned</li>
<li><code>DISTINCT</code>: Distinct uids will be collected. [Defaults to <code>True</code>]</li>
<li><code>DEBUG</code>: If this is set to <code>True</code> the generated SQL and parameters will be returned without making the query.</li>
</ul>
<p>For convenience <code>CHAIN</code> and <code>WHERE</code> are the first two implicit parameters.</p>
<p><strong>Parameters</strong></p>
<p>Every other keyword is treated as a parameter for defining returned values, FTS searches or SQL escaped parameters. </p>
<p>Any extra aliases in the collected item should be defined as a parameter. The result will be available as a key
in the item with the alias preceded by an underscore (i.e. an unsaved value). </p>
<p>If a parameter is the same as a link-alias with "_fts" appended then the value is to be
used in an FTS match. </p>
<p>Values to be SQL escaped whould be inserted by name (e.g. ':p1') where appropriate and the value given by a parameter
(e.g. p1=10).</p>
<p><strong>Example</strong></p>
<pre><code># Fetch the nodes of kind "Person" that are  
# connected by edges of kind "Author" to other 
# nodes of kind "Document" with tiles containing "Quantum"
# and also collect the author order
g.fetch('(n:Document) &lt;(e:Author)- [p:Person,aorder]', n_fts='title: Quantum', aorder='e.data.order')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch(self, CHAIN=&#39;(n)&#39;, WHERE=None, **args):
    &#39;&#39;&#39;
    This is the workhorse for fetching nodes and edges from the database. It&#39;s a thin wrapper around
    SQL so most of the SQL operators are available.
    
    **Keywords**
    
    - `CHAIN`: Description of how to join together nodes and edges for the query. 
               A chain is composed of links read from left to right separated by spaces. 
               Each link can be a node &#34;(n)&#34; or and edge &#34;-(e)&gt;&#34; or &#34;&lt;(e)-&#34;. 
               e.g. &#34;(n1) -[e:Document,title]&gt; (n2)&#34;.
               The variable in the brackets is an alias for the link that can then be used 
               in other parts of the query and should be unique. 
               Square brackets indicate the link to be collected (otherwise defaults to right-most link).
               Square brackets can also have other aliases separated by commas, these should be defined in parameters passed
               to the function.
    - `WHERE`: A string, or list of strings with SQL conditions. If it&#39;s a list the items will be ANDed together
    - `GROUP`: String to follow SQLs GROUP BY
    - `ORDER`: String to follow SQLs ORDER BY
    - `LIMIT`: An interger to limit the numer of items returned
    - `OFFSET`: Return items from offset, used in combination with `LIMIT`
    - `COUNT`: The number of items satisfying the query will be returned
    - `DISTINCT`: Distinct uids will be collected. [Defaults to `True`]
    - `DEBUG`: If this is set to `True` the generated SQL and parameters will be returned without making the query.
    
    For convenience `CHAIN` and `WHERE` are the first two implicit parameters.
    
    **Parameters**
    
    Every other keyword is treated as a parameter for defining returned values, FTS searches or SQL escaped parameters. 
    
    Any extra aliases in the collected item should be defined as a parameter. The result will be available as a key 
    in the item with the alias preceded by an underscore (i.e. an unsaved value). 
    
    If a parameter is the same as a link-alias with &#34;_fts&#34; appended then the value is to be
    used in an FTS match. 
    
    Values to be SQL escaped whould be inserted by name (e.g. &#39;:p1&#39;) where appropriate and the value given by a parameter
    (e.g. p1=10).
    
    **Example**
    
        # Fetch the nodes of kind &#34;Person&#34; that are  
        # connected by edges of kind &#34;Author&#34; to other 
        # nodes of kind &#34;Document&#34; with tiles containing &#34;Quantum&#34;
        # and also collect the author order
        g.fetch(&#39;(n:Document) &lt;(e:Author)- [p:Person,aorder]&#39;, n_fts=&#39;title: Quantum&#39;, aorder=&#39;e.data.order&#39;)
    &#39;&#39;&#39;
    
    ## extract the SQL pieces with sensible defaults
    WHERE=ensurelist(WHERE)
    ORDER=args.get(&#39;ORDER&#39;, None)
    GROUP=args.get(&#39;GROUP&#39;, None)
    LIMIT=args.get(&#39;LIMIT&#39;, None)
    OFFSET=args.get(&#39;OFFSET&#39;, None)
    COUNT=args.get(&#39;COUNT&#39;, False)
    DISTINCT=args.get(&#39;DISTINCT&#39;, True)    
    DEBUG=args.get(&#39;DEBUG&#39;, False)

    ## everything else is a parameter of some sort
    PARAM = {k:v for k,v in args.items() if k not in FETCHKEYWORDS}
                
    ## interpret table joins
    aliases, collect = self._parsechain(CHAIN, PARAM)
        
    SQL = []

    SQLFTS = []
    ## SQL to attach FTS tables ... need to do this fist so we can expand fts aliases with tablename
    ftsexpansions = {}
    for k in aliases.keys():
        ftskey = k+&#39;_fts&#39;
        if ftskey in list(PARAM.keys()):
            ## N.B. want a copy of PARAM.keys() as we might modify PARAM
            item = aliases[k]
            SQLFTS.append(&#39;\nJOIN {ftstable} &#34;{ftskey}&#34; ON {alias}.uid = {ftskey}.uid&#39;.format(
                ftstable=item[&#39;ftstable&#39;], ftskey=ftskey, alias=k))
            ## add an item to PARAM with the FTS term so it&#39;s SQL escaped
            valuekey = ftskey+&#39;_value&#39;
            ## N.B. proper reference using alias has to have table name, e.g. n1_fts.nodefts
            WHERE.append(&#39;{ftskey}.{ftstable} MATCH :{ftsvalue}&#39;.format(
                ftskey=ftskey, ftstable=aliases[k][&#39;ftstable&#39;], ftsvalue=valuekey))
            PARAM[valuekey] = PARAM[ftskey]
            del PARAM[ftskey]
            ftsexpansions[ftskey] = &#34;{}.{}&#34;.format(ftskey,aliases[k][&#39;ftstable&#39;])
        
    def expandfts(ftsstring, ftsexpansions):
        for ftskey, ftsexpanded in ftsexpansions.items():
            ftsstring = ftsstring.replace(ftskey, ftsexpanded)
        return ftsstring
        
    ##
    ## SELECT
    ##
    collect[&#39;distinct&#39;] = &#39;DISTINCT&#39; if DISTINCT else &#39;&#39;
    colkeys = collect[&#39;columns&#39;].copy()
    colsql = [&#39;{}.{}&#39;.format(collect[&#39;alias&#39;],c) for c in colkeys]
    for k,v in collect.get(&#39;extra&#39;,{}).items():
        colkeys.append(k)
        v = jsonextract(v)
        v = expandfts(v, ftsexpansions)
        colsql.append(v)

    collect[&#39;collectcolumns&#39;] = &#39;, &#39;.join(colsql)
    if COUNT:
        SQL.append(&#39;SELECT COUNT({distinct} {alias}.uid) FROM {table} {alias}&#39;.format(**collect))
    else:
        SQL.append(&#39;SELECT {distinct} {collectcolumns} FROM {table} {alias}&#39;.format(**collect))

    
    ##
    ## JOINs
    ##
    ## link tables together
    l = collect        
    while &#39;rightlink&#39; in l:
        r = aliases[l[&#39;rightlink&#39;]]
        r[&#39;join&#39;] = &#39;{}.{} = {}.{}&#39;.format(r[&#39;alias&#39;], r[&#39;leftuid&#39;], l[&#39;alias&#39;], l[&#39;rightuid&#39;])
        if &#39;kind&#39; in r:
            r[&#39;join&#39;] += &#39; AND {}.kind = &#34;{}&#34;&#39;.format(r[&#39;alias&#39;],r[&#39;kind&#39;])
        SQL.append(&#39;\nJOIN {table} {alias} ON {join}&#39;.format(**r))
        l=r
    r = collect
    while &#39;leftlink&#39; in r:
        l = aliases[r[&#39;leftlink&#39;]]
        l[&#39;join&#39;] = &#39;{}.{} = {}.{}&#39;.format(l[&#39;alias&#39;], l[&#39;rightuid&#39;], r[&#39;alias&#39;], r[&#39;leftuid&#39;] )  
        if &#39;kind&#39; in l:
            l[&#39;join&#39;] += &#39; AND {alias}.kind = &#34;{kind}&#34;&#39;.format(**l)
        SQL.append(&#39;\nJOIN {table} {alias} ON {join}&#39;.format(**l))
        r=l

    SQL.extend(SQLFTS)
    
    ##
    ## WHERE
    ##
    if &#39;kind&#39; in collect:
        WHERE.append(&#39;{alias}.kind = &#34;{kind}&#34;&#39;.format(**collect))

    if len(WHERE)&gt;0:
        SQL.append(&#39;\nWHERE &#39;+ &#39; AND &#39;.join([jsonextract(w) for w in WHERE]))
    

    ##
    ## GROUP BY
    ##
    if GROUP is not None:
        SQL.append(&#39;\nGROUP BY {}&#39;.format(expandfts(jsonextract(GROUP), ftsexpansions)))
    
    ##
    ## ORDER BY
    ##
    if ORDER is not None:
        SQL.append(&#39;\nORDER BY {}&#39;.format(expandfts(jsonextract(ORDER),ftsexpansions)))
    
        
    ##
    ## LIMIT and OFFSET
    ##
    if LIMIT is not None:
        SQL.append(&#39;\nLIMIT {}&#39;.format(LIMIT))
    if OFFSET is not None:
        SQL.append(&#39; OFFSET {}&#39;.format(OFFSET))

    SQL = &#39;&#39;.join(SQL)
    ##
    ## Return sql statement if debug
    ##
    if DEBUG:
        return SQL, PARAM
    
    cursor=self.cursor()
        
    ## faster to first create list
    items = []
    
    ##
    ## COUNT
    ##
    if COUNT:
        c = cursor.execute(SQL, PARAM).fetchone()[0]
        return c
    
    ##
    ## COLLECT
    ##        
    elif collect[&#39;type&#39;]==&#39;node&#39;:
        for row in cursor.execute(SQL, PARAM):
            args = json.loads(row[colkeys.index(&#39;data&#39;)])
            for c,v in zip(colkeys, row):
                if c == &#39;data&#39;:
                    continue                        
                else:
                    args[&#39;_&#39;+c] = v
            N = Node(args, graph=self, changed=False)
            items.append(N)
        return NSet(items)
    
    else:
        for row in cursor.execute(SQL, PARAM):
            args = json.loads(row[colkeys.index(&#39;data&#39;)])
            for c,v in zip(colkeys, row):
                if c == &#39;data&#39;:
                    continue                        
                else:
                    args[&#39;_&#39;+c] = v
            E = Edge(args, graph=self, changed=False)
            items.append(E)
        return ESet(items)</code></pre>
</details>
</dd>
<dt id="graphydb.Graph.getsetting"><code class="name flex">
<span>def <span class="ident">getsetting</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Read back a previously saved setting. Value will be de-jsonified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getsetting(self, key):
    &#39;&#39;&#39;
    Read back a previously saved setting. Value will be de-jsonified.
    &#39;&#39;&#39;
    cursor=self.cursor()
    row = cursor.execute(&#39;SELECT value FROM settings WHERE key = ?&#39;,[key]).fetchone()
    if row is None:
        raise KeyError
    
    value = json.loads(row[0])
    return value</code></pre>
</details>
</dd>
<dt id="graphydb.Graph.getuid"><code class="name flex">
<span>def <span class="ident">getuid</span></span>(<span>self, uid)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience function to find either a node or edge with a given uid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getuid(self, uid):
    &#39;&#39;&#39;
    Convenience function to find either a node or edge with a given uid.
    &#39;&#39;&#39;
    
    obj = self.fetch(CHAIN=&#39;(n)&#39;, WHERE=&#39;n.uid = :uid&#39;, uid=uid).one
    if obj is None:
        obj = self.fetch(CHAIN=&#39;-(e)&gt;&#39;, WHERE=&#39;e.uid = :uid&#39;, uid=uid).one
        
    return obj</code></pre>
</details>
</dd>
<dt id="graphydb.Graph.lastchanges"><code class="name flex">
<span>def <span class="ident">lastchanges</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lastchanges(self):
    if self.countchanges()==0:
        ## no changes
        out = []
    else:
        cursor=self.cursor()
        cid, change = cursor.execute(&#39;&#39;&#39;
            SELECT id, change FROM changes
            ORDER BY id DESC LIMIT 1
            &#39;&#39;&#39;).fetchone()
        change = json.loads(change)
        if &#39;batch&#39; not in change:
            ## single change item
            out = [(cid, change)]
        else:
            ## possibly multiple change items in same batch
            rows = cursor.execute(&#39;&#39;&#39;
                SELECT id, change FROM changes
                WHERE json_extract(change, &#34;$.batch&#34;) = ? ORDER BY id&#39;&#39;&#39;, [change[&#39;batch&#39;]]).fetchall()   
            out = [(cid, json.loads(change)) for cid, change in rows]
            
    return out</code></pre>
</details>
</dd>
<dt id="graphydb.Graph.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Drop the tables and recreate them.
<em>All data will be lost!</em></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#39;&#39;&#39;
    Drop the tables and recreate them.
    *All data will be lost!*
    &#39;&#39;&#39;
    cursor=self.cursor()
              
    cursor.execute(&#39;&#39;&#39;
        DROP TABLE IF EXISTS nodes;
        DROP TABLE IF EXISTS edges;
        DROP TABLE IF EXISTS settings;
        DROP TABLE IF EXISTS cache;
        DROP TABLE IF EXISTS changes;
        CREATE TABLE IF NOT EXISTS nodes(uid TEXT PRIMARY KEY, kind TEXT, ctime REAL, mtime REAL, data TEXT);
        CREATE TABLE IF NOT EXISTS edges(uid TEXT PRIMARY KEY, kind TEXT, startuid TEXT NOT NULL REFERENCES nodes(uid), enduid TEXT NOT NULL REFERENCES nodes(uid), ctime REAL, mtime REAL, data TEXT);
        CREATE TABLE IF NOT EXISTS settings(key TEXT PRIMARY KEY, value TEXT);
        CREATE TABLE IF NOT EXISTS cache(key TEXT PRIMARY KEY, value TEXT);
        CREATE TABLE IF NOT EXISTS changes(id INTEGER PRIMARY KEY AUTOINCREMENT, change TEXT);
    &#39;&#39;&#39;)
    
    ## store GraphyDB version that was used to create the database
    self.savesetting(&#39;GraphyDB version&#39;, __version__)</code></pre>
</details>
</dd>
<dt id="graphydb.Graph.resetfts"><code class="name flex">
<span>def <span class="ident">resetfts</span></span>(<span>self, nodefields=None, edgefields=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resetfts(self, nodefields=None, edgefields=None):
            
    ## remove tables
    cursor=self.cursor()
    cursor.execute(&#39;&#39;&#39;
        DROP TABLE IF EXISTS nodefts;
        DROP TABLE IF EXISTS edgefts;
    &#39;&#39;&#39;) 
    
    ## create node table
    if nodefields is not None:
        nodefields = set(nodefields)
        VSTR = &#34;,&#34;.join(nodefields) + &#34;,uid UNINDEXED&#34;
        cursor.execute(&#39;CREATE VIRTUAL TABLE IF NOT EXISTS nodefts USING fts5({});&#39;.format(VSTR))
        
        
    ## create edge table
    if edgefields is not None:
        edgefields = set(edgefields)
        ESTR = &#34;,&#34;.join(edgefields)+&#34;,uid UNINDEXED&#34;
        cursor.execute(&#39;CREATE VIRTUAL TABLE IF NOT EXISTS edgefts USING fts5({});&#39;.format(ESTR))</code></pre>
</details>
</dd>
<dt id="graphydb.Graph.savesetting"><code class="name flex">
<span>def <span class="ident">savesetting</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<div class="desc"><p>A simple key-value store to save settings. Values will be jsonified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def savesetting(self, key, value):
    &#39;&#39;&#39;
    A simple key-value store to save settings. Values will be jsonified.
    &#39;&#39;&#39;
    cursor=self.cursor()
    settings = cursor.execute(&#39;INSERT OR REPLACE INTO settings(key, value) VALUES(?,?)&#39;, (key, json.dumps(value)) )</code></pre>
</details>
</dd>
<dt id="graphydb.Graph.undo"><code class="name flex">
<span>def <span class="ident">undo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Undo the last change to the graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def undo(self):
    &#39;&#39;&#39;
    Undo the last change to the graph.
    &#39;&#39;&#39;
    changes = []
    changebatch=reversed(self.lastchanges())
    for i, change in changebatch:
        if &#39;+&#39; in change and &#39;-&#39; not in change:
            ## change was to add item so undo removes it
            action = &#34;-&#34;
            item = self.getuid(change[&#39;uid&#39;])
            item.delete(setchange=False) 
        elif &#39;-&#39; in change and &#39;+&#39; not in change:
            ## change was to remove item so undo adds it
            action = &#34;+&#34;
            data = change[&#39;-&#39;]
            if &#39;startuid&#39; in data:
                item = Edge(data, graph=self)
            else:
                item = Node(data, graph=self)
            item.save(setchange=False)
        elif &#39;-&#39; in change and &#39;+&#39; in change:
            ## change was to add and remove internals so undo reverses them
            action = &#34;*&#34;
            item = self.getuid(change[&#39;uid&#39;])
            item.data = patch(item.data, change, reverse=True)
            item.save(setchange=False, force=True)
        else:
            raise GraphyDBException(&#39;Unknown undo action&#39;)
        changes.append((action, change[&#39;uid&#39;]))
        self.deletechange(i)
    return changes</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="graphydb.GraphyDBException"><code class="flex name class">
<span>class <span class="ident">GraphyDBException</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Any exceptions thrown by <code><a title="graphydb" href="#graphydb">graphydb</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphyDBException(Exception):
    &#39;&#39;&#39;
    Any exceptions thrown by `graphydb`.
    &#39;&#39;&#39;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="graphydb.GraphyDBItem"><code class="flex name class">
<span>class <span class="ident">GraphyDBItem</span></span>
<span>(</span><span>data, graph=None, changed=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Parent of <code><a title="graphydb.Node" href="#graphydb.Node">Node</a></code> and <code><a title="graphydb.Edge" href="#graphydb.Edge">Edge</a></code> with some common methods. Essentially acts as souped up <code>dict</code>.</p>
<p>GraphyDBItem shoudn't be instantiated directly. Use <code><a title="graphydb.Node" href="#graphydb.Node">Node</a></code> or <code><a title="graphydb.Edge" href="#graphydb.Edge">Edge</a></code> instead.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphyDBItem(MutableMapping):
    &#39;&#39;&#39;
    Parent of `graphydb.Node` and `graphydb.Edge` with some common methods. Essentially acts as souped up `dict`.
    &#39;&#39;&#39;
    
    ## set in derived classes
    _table = &#39;&#39;
    _ftstable = &#39;&#39;    
    
    def __init__(self, data, graph=None, changed=True):
        &#39;&#39;&#39;
        GraphyDBItem shoudn&#39;t be instantiated directly. Use `graphydb.Node` or `graphydb.Edge` instead.
        &#39;&#39;&#39;
        
        self.graph = graph
        &#39;&#39;&#39;
        An instance of the `graphydb.Graph` holding the item.
        &#39;&#39;&#39;                
        
        if &#39;uid&#39; not in data:
            data[&#39;uid&#39;] = generateUUID()   
        if &#39;ctime&#39; not in data:
            data[&#39;ctime&#39;] = time.time()
        if &#39;mtime&#39; not in data:
            data[&#39;mtime&#39;] = time.time()         
        
        self.data = data
        &#39;&#39;&#39;Straight python dictionary that holds all the data. Keys begining with an underscore (&#34;_&#34;)
        will be ignored when saving and can be used to store local temporary data.
        Modifying the data directly is not recommended as what&#39;s changed will not be recorded.&#39;&#39;&#39;    
        
        self.setChanged(changed)      
      
    def setGraph(self, graph, changed=True):
        &#39;&#39;&#39;
        Set the graph for the item.
        &#39;&#39;&#39;
        self.graph = graph
        
        self.setChanged(changed)      
        return self
      
    def __uid__(self):
        return self.data[&#39;uid&#39;]
    
    def setChanged(self, changed):
        &#39;&#39;&#39;
        Mark all keys as having changed.
        &#39;&#39;&#39;
        if changed:
            ## regard all keys as having changed
            self._changedkeys = set(self.keys())
        else:
            self._changedkeys = set()   
            
    @property   
    def changed(self):
        &#39;&#39;&#39;
        Returns True is any key is marked as changed.
        &#39;&#39;&#39;
        return len(self._changedkeys)&gt;0
        
    @property
    def exists(self):
        &#39;&#39;&#39;
        Property: return True if item exists in the database otherwise False.
        &#39;&#39;&#39;
        cursor = self.graph.cursor()
        n = cursor.execute(&#39;SELECT COUNT(*) FROM {} WHERE uid = ?&#39;.format(self._table), (self[&#39;uid&#39;],)).fetchone()[0]
        if n==1:
            return True
        else:
            return False    

    def original(self):
        &#39;&#39;&#39;
        Return item fresh from database. 
        &#39;&#39;&#39;
        item = self.graph.getuid(self[&#39;uid&#39;])
        return item
    
    def renew(self):
        &#39;&#39;&#39;
        Load data from database again. 
        Any local changes are discarded without setting a change item.
        Keys starting with an underscore are undisturbed.
        &#39;&#39;&#39;
        original = self.original()
        ## copy accross the undescore keys
        for k,v in self.data.items():
            if k[0]==&#39;_&#39;:
                original.data[k] = v
                
        ## copy across the refreshed dataset
        self.data = original.data
        self.setChanged(False)
        return self
        
    def updatefts(self, **data):
        &#39;&#39;&#39;
        Update FTS for the item.
        &#39;&#39;&#39;
        if len(data)&gt;0:
            cursor = self.graph.cursor()
            
            ## filter on existing column names
            columnames = [x[1] for x in cursor.execute(&#39;PRAGMA table_info({})&#39;.format(self._ftstable)).fetchall()]
            keys = []
            values = []
            for k,v in data.items():
                if k in columnames:
                    keys.append(k)
                    values.append(v)
            if len(keys)==0:
                return
            
            n = cursor.execute(&#34;SELECT COUNT(*) FROM {} WHERE uid = ?&#34;.format(self._ftstable), [self[&#39;uid&#39;]]).fetchone()[0]
            if n &gt; 0:
                ## use UPDATE
                keystr = &#34;,&#34;.join( [&#34;{} = ?&#34;.format(k) for k in keys] )
                query = &#39;UPDATE {} SET {} WHERE uid = &#34;{}&#34;&#39;.format(self._ftstable, keystr, self[&#39;uid&#39;])
            else:
                ## use INSERT
                keystr = &#34;,&#34;.join(keys)+&#34;,uid&#34;
                values.append(self[&#39;uid&#39;])
                qstr = &#34;,&#34;.join([&#39;?&#39;]*len(values))
                query = &#39;INSERT INTO {}({}) VALUES ({})&#39;.format(self._ftstable, keystr, qstr)
                
            cursor.execute(query, values)
        return self

            
    def set(self, **attr):
        &#39;&#39;&#39;
        Set a bunch of keys in one go.
        &#39;&#39;&#39;
        for k,v in attr.items():
            self[k] = v
            self._changedkeys.add(k)
        return self

    def __getitem__(self, key):
        if key in self.data:
            return self.data[key]
        if hasattr(self.__class__, &#34;__missing__&#34;):
            return self.__class__.__missing__(self, key)
        raise KeyError(key)
    
    def __setitem__(self, key, item):
        self.data.__setitem__(key, item)
        if key != &#39;mtime&#39;:
            # avoid recursion!
            self[&#39;mtime&#39;] = time.time()
        self._changedkeys.add(key)
        
    def __delitem__(self, key):
        self.data.__delitem__(key)
        if key != &#39;mtime&#39;:
            # avoid recursion!
            self[&#39;mtime&#39;] = time.time()
        self._changedkeys.add(key)
    
    def deletefts(self):
        &#39;&#39;&#39;
        Remove the FTS data for this item.
        &#39;&#39;&#39;
        cursor = self.graph.cursor()
        if cursor.execute(&#34;SELECT count(*) FROM sqlite_master WHERE type=&#39;table&#39; AND name=&#39;{}&#39;;&#34;.format(self._ftstable)).fetchone()[0] &gt;0:
            cursor.execute(&#39;DELETE FROM {} WHERE uid = ?&#39;.format(self._ftstable), (self[&#39;uid&#39;],))
        return self
            
    def __len__(self): 
        return len(self.data)

    def __iter__(self):
        return iter(self.data)

    def __contains__(self, key):
        return key in self.data

    ## Now, add the methods in dicts but not in MutableMapping
    
    def __repr__(self): 
        return repr(self.data)
    
    def copy(self):
        data = self.data
        try:
            self.data = {}
            c = copy.copy(self)
        finally:
            self.data = data
        c.update(self)
        c._changedkeys = set(self._changedkeys)
        return c
    
    def deepcopy(self):
        data = self.data
        try:
            self.data = {}
            c = copy.deepcopy(self)
        finally:
            self.data = data
        c.data = copy.deepcopy(data)
        return c        
    
    @classmethod
    def fromkeys(cls, iterable, value=None):
        d = cls()
        for key in iterable:
            d[key] = value
            self._changedkeys.add(key)
        return d</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="graphydb.Edge" href="#graphydb.Edge">Edge</a></li>
<li><a title="graphydb.Node" href="#graphydb.Node">Node</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="graphydb.GraphyDBItem.fromkeys"><code class="name flex">
<span>def <span class="ident">fromkeys</span></span>(<span>iterable, value=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fromkeys(cls, iterable, value=None):
    d = cls()
    for key in iterable:
        d[key] = value
        self._changedkeys.add(key)
    return d</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="graphydb.GraphyDBItem.changed"><code class="name">var <span class="ident">changed</span></code></dt>
<dd>
<div class="desc"><p>Returns True is any key is marked as changed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property   
def changed(self):
    &#39;&#39;&#39;
    Returns True is any key is marked as changed.
    &#39;&#39;&#39;
    return len(self._changedkeys)&gt;0</code></pre>
</details>
</dd>
<dt id="graphydb.GraphyDBItem.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Straight python dictionary that holds all the data. Keys begining with an underscore ("_")
will be ignored when saving and can be used to store local temporary data.
Modifying the data directly is not recommended as what's changed will not be recorded.</p></div>
</dd>
<dt id="graphydb.GraphyDBItem.exists"><code class="name">var <span class="ident">exists</span></code></dt>
<dd>
<div class="desc"><p>Property: return True if item exists in the database otherwise False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exists(self):
    &#39;&#39;&#39;
    Property: return True if item exists in the database otherwise False.
    &#39;&#39;&#39;
    cursor = self.graph.cursor()
    n = cursor.execute(&#39;SELECT COUNT(*) FROM {} WHERE uid = ?&#39;.format(self._table), (self[&#39;uid&#39;],)).fetchone()[0]
    if n==1:
        return True
    else:
        return False    </code></pre>
</details>
</dd>
<dt id="graphydb.GraphyDBItem.graph"><code class="name">var <span class="ident">graph</span></code></dt>
<dd>
<div class="desc"><p>An instance of the <code><a title="graphydb.Graph" href="#graphydb.Graph">Graph</a></code> holding the item.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="graphydb.GraphyDBItem.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    data = self.data
    try:
        self.data = {}
        c = copy.copy(self)
    finally:
        self.data = data
    c.update(self)
    c._changedkeys = set(self._changedkeys)
    return c</code></pre>
</details>
</dd>
<dt id="graphydb.GraphyDBItem.deepcopy"><code class="name flex">
<span>def <span class="ident">deepcopy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deepcopy(self):
    data = self.data
    try:
        self.data = {}
        c = copy.deepcopy(self)
    finally:
        self.data = data
    c.data = copy.deepcopy(data)
    return c        </code></pre>
</details>
</dd>
<dt id="graphydb.GraphyDBItem.deletefts"><code class="name flex">
<span>def <span class="ident">deletefts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the FTS data for this item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deletefts(self):
    &#39;&#39;&#39;
    Remove the FTS data for this item.
    &#39;&#39;&#39;
    cursor = self.graph.cursor()
    if cursor.execute(&#34;SELECT count(*) FROM sqlite_master WHERE type=&#39;table&#39; AND name=&#39;{}&#39;;&#34;.format(self._ftstable)).fetchone()[0] &gt;0:
        cursor.execute(&#39;DELETE FROM {} WHERE uid = ?&#39;.format(self._ftstable), (self[&#39;uid&#39;],))
    return self</code></pre>
</details>
</dd>
<dt id="graphydb.GraphyDBItem.original"><code class="name flex">
<span>def <span class="ident">original</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return item fresh from database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def original(self):
    &#39;&#39;&#39;
    Return item fresh from database. 
    &#39;&#39;&#39;
    item = self.graph.getuid(self[&#39;uid&#39;])
    return item</code></pre>
</details>
</dd>
<dt id="graphydb.GraphyDBItem.renew"><code class="name flex">
<span>def <span class="ident">renew</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Load data from database again.
Any local changes are discarded without setting a change item.
Keys starting with an underscore are undisturbed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def renew(self):
    &#39;&#39;&#39;
    Load data from database again. 
    Any local changes are discarded without setting a change item.
    Keys starting with an underscore are undisturbed.
    &#39;&#39;&#39;
    original = self.original()
    ## copy accross the undescore keys
    for k,v in self.data.items():
        if k[0]==&#39;_&#39;:
            original.data[k] = v
            
    ## copy across the refreshed dataset
    self.data = original.data
    self.setChanged(False)
    return self</code></pre>
</details>
</dd>
<dt id="graphydb.GraphyDBItem.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, **attr)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a bunch of keys in one go.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, **attr):
    &#39;&#39;&#39;
    Set a bunch of keys in one go.
    &#39;&#39;&#39;
    for k,v in attr.items():
        self[k] = v
        self._changedkeys.add(k)
    return self</code></pre>
</details>
</dd>
<dt id="graphydb.GraphyDBItem.setChanged"><code class="name flex">
<span>def <span class="ident">setChanged</span></span>(<span>self, changed)</span>
</code></dt>
<dd>
<div class="desc"><p>Mark all keys as having changed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setChanged(self, changed):
    &#39;&#39;&#39;
    Mark all keys as having changed.
    &#39;&#39;&#39;
    if changed:
        ## regard all keys as having changed
        self._changedkeys = set(self.keys())
    else:
        self._changedkeys = set()   </code></pre>
</details>
</dd>
<dt id="graphydb.GraphyDBItem.setGraph"><code class="name flex">
<span>def <span class="ident">setGraph</span></span>(<span>self, graph, changed=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the graph for the item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setGraph(self, graph, changed=True):
    &#39;&#39;&#39;
    Set the graph for the item.
    &#39;&#39;&#39;
    self.graph = graph
    
    self.setChanged(changed)      
    return self</code></pre>
</details>
</dd>
<dt id="graphydb.GraphyDBItem.updatefts"><code class="name flex">
<span>def <span class="ident">updatefts</span></span>(<span>self, **data)</span>
</code></dt>
<dd>
<div class="desc"><p>Update FTS for the item.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updatefts(self, **data):
    &#39;&#39;&#39;
    Update FTS for the item.
    &#39;&#39;&#39;
    if len(data)&gt;0:
        cursor = self.graph.cursor()
        
        ## filter on existing column names
        columnames = [x[1] for x in cursor.execute(&#39;PRAGMA table_info({})&#39;.format(self._ftstable)).fetchall()]
        keys = []
        values = []
        for k,v in data.items():
            if k in columnames:
                keys.append(k)
                values.append(v)
        if len(keys)==0:
            return
        
        n = cursor.execute(&#34;SELECT COUNT(*) FROM {} WHERE uid = ?&#34;.format(self._ftstable), [self[&#39;uid&#39;]]).fetchone()[0]
        if n &gt; 0:
            ## use UPDATE
            keystr = &#34;,&#34;.join( [&#34;{} = ?&#34;.format(k) for k in keys] )
            query = &#39;UPDATE {} SET {} WHERE uid = &#34;{}&#34;&#39;.format(self._ftstable, keystr, self[&#39;uid&#39;])
        else:
            ## use INSERT
            keystr = &#34;,&#34;.join(keys)+&#34;,uid&#34;
            values.append(self[&#39;uid&#39;])
            qstr = &#34;,&#34;.join([&#39;?&#39;]*len(values))
            query = &#39;INSERT INTO {}({}) VALUES ({})&#39;.format(self._ftstable, keystr, qstr)
            
        cursor.execute(query, values)
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="graphydb.GraphyDBItemSet"><code class="flex name class">
<span>class <span class="ident">GraphyDBItemSet</span></span>
<span>(</span><span>iterable=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Super class of sets <code><a title="graphydb.NSet" href="#graphydb.NSet">NSet</a></code> and <code><a title="graphydb.ESet" href="#graphydb.ESet">ESet</a></code> holding nodes and edges.
Operations between sets will be based entirely on the items
<code>__uid__()</code> not on their content.
Methods will return a reference to itself where appropriate to allow chaining of commands.</p>
<p>Takes an interable of objects with a <code>__uid__()</code> method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphyDBItemSet(IndexedSet):
    &#39;&#39;&#39;
    Super class of sets `graphydb.NSet` and `graphydb.ESet` holding nodes and edges.
    Operations between sets will be based entirely on the items  `__uid__()` not on their content.
    Methods will return a reference to itself where appropriate to allow chaining of commands.
    &#39;&#39;&#39;
    
    def setGraph(self, graph, changed=True):
        &#39;&#39;&#39;
        Set the graph on all contained items. Items not saved to new graph automatically.
        &#39;&#39;&#39;
        for item in self:
            item.setGraph(graph, changed)
        return self
    
    def save(self, force=False, batch=None, setchange=True):
        &#39;&#39;&#39;
        Save all items to the database.
        
        - `force`: if `True`, save regardless if the item has changed.
        &#39;&#39;&#39;
        if batch is None:
            ## since we&#39;re saving in a group this should be batched
            batch = generateUUID()        

        for item in self:
            item.save(force=force, batch=batch, setchange=setchange)
        return self
            
    
    def filter(self, function):
        &#39;&#39;&#39;
        Pythonic filter method on the set. Returns a set with items where the function
        returns `True`. Returned items are referenced not copies.
        
            fruits = [&#39;Orange&#39;,&#39;Apple&#39;,&#39;Pear&#39;]
            barset = fooset.filter(lambda n: n[&#39;fruit&#39;] in fruits])
        &#39;&#39;&#39;
        ## ensure we have the same type of set: either NSet or Eset
        out = self.__class__()
        
        ## this way is about twice as slow as using filter
        ## but we can make it insensitive to missing keys etc
        for item in self:
            try:
                if function(item):
                    out.add(item)
            except:
                pass
        return out
    
    def filter_fnmatch(self, **attr):
        &#39;&#39;&#39;
        Apply `fnmatch` to all the keys given and return the set of items that match. 
        Returned items are referenced not copies.
        
            barset = fooset.filter_fnmatch(title=&#39;Once Upon *&#39;)
        &#39;&#39;&#39;
        
        out = self.__class__()
        
        for item in self:
            found = True
            for key, pattern in attr.items():
                try:
                    found = found and fnmatch.fnmatch(item[key], pattern)
                except KeyError:
                    found = False
                    break  
            if found:
                out.add(item)
                
        return out
    
    @property
    def one(self):
        &#39;&#39;&#39;
        Return a single item from set or `None` if empty. Set not modified.
        &#39;&#39;&#39;
        if len(self)==0:
            return None
        else:
            return self[0]

    def get(self, key, default=None):
        &#39;&#39;&#39;
        Get the values of the key for each item in the set as a list. 
        Return the `default` for each item without that key.
        &#39;&#39;&#39;
        out = []
        for item in self:
            out.append(item.get(key, default))
        return out

    def getm(self, *keys, default=None):
        &#39;&#39;&#39;
        Get a list of values of the keys for each item in the set as a list. 
        Return the `default` for each item without a key.
        &#39;&#39;&#39;
        out = []
        for item in self:
            out.append([item.get(key, default) for key in keys])
        return out  
  
    def set(self, **attr):
        &#39;&#39;&#39;
        Set a bunch of attributes in one go on each item in the set.
        &#39;&#39;&#39;
        for item in self:
            item.set(**attr)
        return self
    
    def deletefts(self):
        &#39;&#39;&#39;
        Remove the FTS data from the database for the items in the set.
        &#39;&#39;&#39;
        for item in self:
            item.deletefts()
        return self</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="graphydb.IndexedSet" href="#graphydb.IndexedSet">IndexedSet</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="graphydb.ESet" href="#graphydb.ESet">ESet</a></li>
<li><a title="graphydb.NSet" href="#graphydb.NSet">NSet</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="graphydb.GraphyDBItemSet.one"><code class="name">var <span class="ident">one</span></code></dt>
<dd>
<div class="desc"><p>Return a single item from set or <code>None</code> if empty. Set not modified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def one(self):
    &#39;&#39;&#39;
    Return a single item from set or `None` if empty. Set not modified.
    &#39;&#39;&#39;
    if len(self)==0:
        return None
    else:
        return self[0]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="graphydb.GraphyDBItemSet.deletefts"><code class="name flex">
<span>def <span class="ident">deletefts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the FTS data from the database for the items in the set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deletefts(self):
    &#39;&#39;&#39;
    Remove the FTS data from the database for the items in the set.
    &#39;&#39;&#39;
    for item in self:
        item.deletefts()
    return self</code></pre>
</details>
</dd>
<dt id="graphydb.GraphyDBItemSet.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, function)</span>
</code></dt>
<dd>
<div class="desc"><p>Pythonic filter method on the set. Returns a set with items where the function
returns <code>True</code>. Returned items are referenced not copies.</p>
<pre><code>fruits = ['Orange','Apple','Pear']
barset = fooset.filter(lambda n: n['fruit'] in fruits])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, function):
    &#39;&#39;&#39;
    Pythonic filter method on the set. Returns a set with items where the function
    returns `True`. Returned items are referenced not copies.
    
        fruits = [&#39;Orange&#39;,&#39;Apple&#39;,&#39;Pear&#39;]
        barset = fooset.filter(lambda n: n[&#39;fruit&#39;] in fruits])
    &#39;&#39;&#39;
    ## ensure we have the same type of set: either NSet or Eset
    out = self.__class__()
    
    ## this way is about twice as slow as using filter
    ## but we can make it insensitive to missing keys etc
    for item in self:
        try:
            if function(item):
                out.add(item)
        except:
            pass
    return out</code></pre>
</details>
</dd>
<dt id="graphydb.GraphyDBItemSet.filter_fnmatch"><code class="name flex">
<span>def <span class="ident">filter_fnmatch</span></span>(<span>self, **attr)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply <code>fnmatch</code> to all the keys given and return the set of items that match.
Returned items are referenced not copies.</p>
<pre><code>barset = fooset.filter_fnmatch(title='Once Upon *')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_fnmatch(self, **attr):
    &#39;&#39;&#39;
    Apply `fnmatch` to all the keys given and return the set of items that match. 
    Returned items are referenced not copies.
    
        barset = fooset.filter_fnmatch(title=&#39;Once Upon *&#39;)
    &#39;&#39;&#39;
    
    out = self.__class__()
    
    for item in self:
        found = True
        for key, pattern in attr.items():
            try:
                found = found and fnmatch.fnmatch(item[key], pattern)
            except KeyError:
                found = False
                break  
        if found:
            out.add(item)
            
    return out</code></pre>
</details>
</dd>
<dt id="graphydb.GraphyDBItemSet.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, key, default=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the values of the key for each item in the set as a list.
Return the <code>default</code> for each item without that key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, key, default=None):
    &#39;&#39;&#39;
    Get the values of the key for each item in the set as a list. 
    Return the `default` for each item without that key.
    &#39;&#39;&#39;
    out = []
    for item in self:
        out.append(item.get(key, default))
    return out</code></pre>
</details>
</dd>
<dt id="graphydb.GraphyDBItemSet.getm"><code class="name flex">
<span>def <span class="ident">getm</span></span>(<span>self, *keys, default=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a list of values of the keys for each item in the set as a list.
Return the <code>default</code> for each item without a key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getm(self, *keys, default=None):
    &#39;&#39;&#39;
    Get a list of values of the keys for each item in the set as a list. 
    Return the `default` for each item without a key.
    &#39;&#39;&#39;
    out = []
    for item in self:
        out.append([item.get(key, default) for key in keys])
    return out  </code></pre>
</details>
</dd>
<dt id="graphydb.GraphyDBItemSet.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, force=False, batch=None, setchange=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Save all items to the database.</p>
<ul>
<li><code>force</code>: if <code>True</code>, save regardless if the item has changed.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, force=False, batch=None, setchange=True):
    &#39;&#39;&#39;
    Save all items to the database.
    
    - `force`: if `True`, save regardless if the item has changed.
    &#39;&#39;&#39;
    if batch is None:
        ## since we&#39;re saving in a group this should be batched
        batch = generateUUID()        

    for item in self:
        item.save(force=force, batch=batch, setchange=setchange)
    return self</code></pre>
</details>
</dd>
<dt id="graphydb.GraphyDBItemSet.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, **attr)</span>
</code></dt>
<dd>
<div class="desc"><p>Set a bunch of attributes in one go on each item in the set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, **attr):
    &#39;&#39;&#39;
    Set a bunch of attributes in one go on each item in the set.
    &#39;&#39;&#39;
    for item in self:
        item.set(**attr)
    return self</code></pre>
</details>
</dd>
<dt id="graphydb.GraphyDBItemSet.setGraph"><code class="name flex">
<span>def <span class="ident">setGraph</span></span>(<span>self, graph, changed=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the graph on all contained items. Items not saved to new graph automatically.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setGraph(self, graph, changed=True):
    &#39;&#39;&#39;
    Set the graph on all contained items. Items not saved to new graph automatically.
    &#39;&#39;&#39;
    for item in self:
        item.setGraph(graph, changed)
    return self</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="graphydb.IndexedSet" href="#graphydb.IndexedSet">IndexedSet</a></b></code>:
<ul class="hlist">
<li><code><a title="graphydb.IndexedSet.add" href="#graphydb.IndexedSet.add">add</a></code></li>
<li><code><a title="graphydb.IndexedSet.append" href="#graphydb.IndexedSet.append">append</a></code></li>
<li><code><a title="graphydb.IndexedSet.clear" href="#graphydb.IndexedSet.clear">clear</a></code></li>
<li><code><a title="graphydb.IndexedSet.copy" href="#graphydb.IndexedSet.copy">copy</a></code></li>
<li><code><a title="graphydb.IndexedSet.discard" href="#graphydb.IndexedSet.discard">discard</a></code></li>
<li><code><a title="graphydb.IndexedSet.pop" href="#graphydb.IndexedSet.pop">pop</a></code></li>
<li><code><a title="graphydb.IndexedSet.remove" href="#graphydb.IndexedSet.remove">remove</a></code></li>
<li><code><a title="graphydb.IndexedSet.reverse" href="#graphydb.IndexedSet.reverse">reverse</a></code></li>
<li><code><a title="graphydb.IndexedSet.sort" href="#graphydb.IndexedSet.sort">sort</a></code></li>
<li><code><a title="graphydb.IndexedSet.update" href="#graphydb.IndexedSet.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="graphydb.IndexedSet"><code class="flex name class">
<span>class <span class="ident">IndexedSet</span></span>
<span>(</span><span>iterable=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Implements an indexed and sorted set.</p>
<p>The collection supports a subset of list, set, and dict operations. </p>
<p>The objects in the collection must expose a <code>__uid__()</code> method that returns a unique string uid
for the object. This uid is what will be used to index the object and in set comparisons.</p>
<p>Items are maintained in order and are indexed so can be looked up by uid. Internally, the data is
stored in a dict <code>_index</code> <em>and</em> list <code>_list</code>, but these shouldn't be modified directly as
they need to be kept in sync.</p>
<p>Speed of set operations are about 10x slower than native sets but with a much faster
creation time for populating the collection. Since set operations are already really fast,
the collection has been optimised to reduce the creation time to have overall performance.</p>
<p>Takes an interable of objects with a <code>__uid__()</code> method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IndexedSet:
    &#39;&#39;&#39;
    Implements an indexed and sorted set.
    
    The collection supports a subset of list, set, and dict operations. 
    
    The objects in the collection must expose a `__uid__()` method that returns a unique string uid 
    for the object. This uid is what will be used to index the object and in set comparisons.
    
    Items are maintained in order and are indexed so can be looked up by uid. Internally, the data is 
    stored in a dict `_index` *and* list `_list`, but these shouldn&#39;t be modified directly as
    they need to be kept in sync.
    
    Speed of set operations are about 10x slower than native sets but with a much faster
    creation time for populating the collection. Since set operations are already really fast, 
    the collection has been optimised to reduce the creation time to have overall performance.
    &#39;&#39;&#39;
        
    def __init__(self, iterable=[]):
        &#39;&#39;&#39;
        Takes an interable of objects with a `__uid__()` method. 
        &#39;&#39;&#39;
        self._index = {n.__uid__():n for n in iterable}
        self._list = list(iterable)
        if len(self._list) != len(self._index.keys()):
            ## iterable contains duplicates. Base the list on the _index.
            self._list = list(self._index.values())

    def copy(self):
        &#39;&#39;&#39;
        Return a shallow copy. 
        
        This means any mutable objects inside the 
        collected object with be references to the original.
        &#39;&#39;&#39;
        ## N.B. in __init__ a shallow copy is made anyway  
        ## but it&#39;s faster to copy the parsed structures
        new = self.__class__()
        new._index = self._index.copy()
        new._list = self._list.copy()
        return new

    #
    # list methods
    #
    
    def sort(self, key=None, reverse=False):
        &#39;&#39;&#39;
        Sort items in place. Returns reference.
        &#39;&#39;&#39;
        self._list.sort(key=key, reverse=reverse)
        return self
        
    def __getitem__(self, key):
        if isinstance(key, slice):
            return self.__class__(self._list[key])
        elif isinstance(key, str):
            return self._index[key]
        else:
            return self._list[key]
        
    def __iter__(self):  
        return iter(self._list)
    
    def reverse(self):
        &#39;&#39;&#39;
        Reverse item order in place. Returns reference.
        &#39;&#39;&#39;
        self._list.reverse()
        return self

    def __delitem__(self, i):
        if isinstance(i, slice):
            values = self._list[i]
        else:
            values = [self._list[i]]
        for v in values:
            del self._index[v.__uid__()]
        del self._list[i]
    
    def __repr__(self):
        return &#34;{{{}}}&#34;.format(self._list.__repr__()) 

    def append(self, item):
        &#39;&#39;&#39;
        Append an item to collection, 
        overwriting and moving to end if present (by uid).
        Returns reference.
        &#39;&#39;&#39;
        self.discard(item)
        uid = item.__uid__()
        self._index[uid] = item
        self._list.append(item)  
        return self
    
    #
    # set methods
    #
    
    def clear(self):
        &#39;&#39;&#39;
        Clear all the contents. Returns reference.
        &#39;&#39;&#39;
        self._list = list()
        self._index = dict()
        return self
    
    def add(self, item):
        &#39;&#39;&#39;
        Add an item to collection, 
        overwriting if already present (by uid) and keeping position.
        Returns reference.
        &#39;&#39;&#39;
        uid = item.__uid__()
        if uid in self._index:
            current = self._index[uid]
            self._index[uid] = item
            idx = self._list.index(current)
            self._list[idx] = item
        else:
            self._list.append(item)
            self._index[uid]=item
        return self

    def remove(self, item):
        &#39;&#39;&#39;
        Remove item (with same uid) from the collection.
        Raise KeyError if item not present.
        Returns reference.
        &#39;&#39;&#39;
        uid = item.__uid__()
        ## make sure it is the item in collection with same uid
        actualitem = self._index[uid]
        self._list.remove(actualitem)
        del self._index[uid]
        return self
     
    def discard(self, item):
        &#39;&#39;&#39;
        Remove item (with same uid) from the collection.
        Ignore if item not present.
        Returns reference.
        &#39;&#39;&#39;
        uid = item.__uid__()
        if uid in self._index:
            ## make sure it is the item in collection with same uid
            actualitem = self._index[uid]
            self._list.remove(actualitem)
            del self._index[uid]
        return self
    
    def __lt__(self, other):
        return self._index.keys().__lt__(other._index.keys())
    def __le__(self, other):
        return self._index.keys().__le__(other._index.keys())
    def __eq__(self, other):
        return self._index.keys().__eq__(other._index.keys())
    def __ne__(self, other):
        return self._index.keys().__ne__(other._index.keys())
    def __gt__(self, other):
        return self._index.keys().__gt__(other._index.keys())
    def __ge__(self, other):
        return self._index.keys().__ge__(other._index.keys())
    def __cmp__(self, other):
        return self._index.keys().__cmp__(other._index.keys())

    def union(self, *others):
        return functools.reduce(lambda x,y:x|y,others, self) 
    def intersection(self, *others):
        return functools.reduce(lambda x,y:x&amp;y,others, self)
    def difference(self, *others):
        return functools.reduce(lambda x,y:x-y,others, self)   

    def symmetric_difference(self, other):
        ## N.B. keys() has no symmetric_difference() so convert to full set first
        keys = set(self._index.keys()).symmetric_difference(other._index.keys())
        return self.__class__(conditionalyield(keys,self._index,other._index))

    def __and__(self, other):
        keys = self._index.keys().__and__(other._index.keys())
        return self.__class__(conditionalyield(keys,self._index,other._index))
    def __xor__(self, other):
        keys = self._index.keys().__xor__(other._index.keys())
        return self.__class__(conditionalyield(keys,self._index,other._index))
    def __or__(self, other):
        keys = self._index.keys().__or__(other._index.keys())
        return self.__class__(conditionalyield(keys, self._index, other._index))
    def __sub__(self, other):
        keys = self._index.keys().__sub__(other._index.keys())
        return self.__class__(conditionalyield(keys, self._index, other._index))
            
    #
    # common methods
    #
       
    def __len__(self):
        return self._index.__len__()
    
    def __contains__(self, item):
        &#39;&#39;&#39;
        Based on uid only.
        &#39;&#39;&#39;
        return self._index.__contains__(item)
    
    def pop(self, idx=-1):
        &#39;&#39;&#39;
        Retrieves the item at location `idx` and also removes it. Defaults to end of list.
        &#39;&#39;&#39;
        item = self._list.pop(idx)
        del self._index[item.__uid__()]
        return item
           
    def update(self, *iterables):
        &#39;&#39;&#39;
        Uodate the existing items with the items in `*iterables`.
        Returns reference.
        &#39;&#39;&#39;
        _add = self.add
        for iterable in iterables:
            for value in iterable:
                _add(value)
        return self</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="graphydb.GraphyDBItemSet" href="#graphydb.GraphyDBItemSet">GraphyDBItemSet</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="graphydb.IndexedSet.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"><p>Add an item to collection,
overwriting if already present (by uid) and keeping position.
Returns reference.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, item):
    &#39;&#39;&#39;
    Add an item to collection, 
    overwriting if already present (by uid) and keeping position.
    Returns reference.
    &#39;&#39;&#39;
    uid = item.__uid__()
    if uid in self._index:
        current = self._index[uid]
        self._index[uid] = item
        idx = self._list.index(current)
        self._list[idx] = item
    else:
        self._list.append(item)
        self._index[uid]=item
    return self</code></pre>
</details>
</dd>
<dt id="graphydb.IndexedSet.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"><p>Append an item to collection,
overwriting and moving to end if present (by uid).
Returns reference.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, item):
    &#39;&#39;&#39;
    Append an item to collection, 
    overwriting and moving to end if present (by uid).
    Returns reference.
    &#39;&#39;&#39;
    self.discard(item)
    uid = item.__uid__()
    self._index[uid] = item
    self._list.append(item)  
    return self</code></pre>
</details>
</dd>
<dt id="graphydb.IndexedSet.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear all the contents. Returns reference.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#39;&#39;&#39;
    Clear all the contents. Returns reference.
    &#39;&#39;&#39;
    self._list = list()
    self._index = dict()
    return self</code></pre>
</details>
</dd>
<dt id="graphydb.IndexedSet.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a shallow copy. </p>
<p>This means any mutable objects inside the
collected object with be references to the original.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#39;&#39;&#39;
    Return a shallow copy. 
    
    This means any mutable objects inside the 
    collected object with be references to the original.
    &#39;&#39;&#39;
    ## N.B. in __init__ a shallow copy is made anyway  
    ## but it&#39;s faster to copy the parsed structures
    new = self.__class__()
    new._index = self._index.copy()
    new._list = self._list.copy()
    return new</code></pre>
</details>
</dd>
<dt id="graphydb.IndexedSet.difference"><code class="name flex">
<span>def <span class="ident">difference</span></span>(<span>self, *others)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def difference(self, *others):
    return functools.reduce(lambda x,y:x-y,others, self)   </code></pre>
</details>
</dd>
<dt id="graphydb.IndexedSet.discard"><code class="name flex">
<span>def <span class="ident">discard</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove item (with same uid) from the collection.
Ignore if item not present.
Returns reference.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def discard(self, item):
    &#39;&#39;&#39;
    Remove item (with same uid) from the collection.
    Ignore if item not present.
    Returns reference.
    &#39;&#39;&#39;
    uid = item.__uid__()
    if uid in self._index:
        ## make sure it is the item in collection with same uid
        actualitem = self._index[uid]
        self._list.remove(actualitem)
        del self._index[uid]
    return self</code></pre>
</details>
</dd>
<dt id="graphydb.IndexedSet.intersection"><code class="name flex">
<span>def <span class="ident">intersection</span></span>(<span>self, *others)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersection(self, *others):
    return functools.reduce(lambda x,y:x&amp;y,others, self)</code></pre>
</details>
</dd>
<dt id="graphydb.IndexedSet.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self, idx=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the item at location <code>idx</code> and also removes it. Defaults to end of list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self, idx=-1):
    &#39;&#39;&#39;
    Retrieves the item at location `idx` and also removes it. Defaults to end of list.
    &#39;&#39;&#39;
    item = self._list.pop(idx)
    del self._index[item.__uid__()]
    return item</code></pre>
</details>
</dd>
<dt id="graphydb.IndexedSet.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove item (with same uid) from the collection.
Raise KeyError if item not present.
Returns reference.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, item):
    &#39;&#39;&#39;
    Remove item (with same uid) from the collection.
    Raise KeyError if item not present.
    Returns reference.
    &#39;&#39;&#39;
    uid = item.__uid__()
    ## make sure it is the item in collection with same uid
    actualitem = self._index[uid]
    self._list.remove(actualitem)
    del self._index[uid]
    return self</code></pre>
</details>
</dd>
<dt id="graphydb.IndexedSet.reverse"><code class="name flex">
<span>def <span class="ident">reverse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reverse item order in place. Returns reference.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reverse(self):
    &#39;&#39;&#39;
    Reverse item order in place. Returns reference.
    &#39;&#39;&#39;
    self._list.reverse()
    return self</code></pre>
</details>
</dd>
<dt id="graphydb.IndexedSet.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self, key=None, reverse=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sort items in place. Returns reference.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self, key=None, reverse=False):
    &#39;&#39;&#39;
    Sort items in place. Returns reference.
    &#39;&#39;&#39;
    self._list.sort(key=key, reverse=reverse)
    return self</code></pre>
</details>
</dd>
<dt id="graphydb.IndexedSet.symmetric_difference"><code class="name flex">
<span>def <span class="ident">symmetric_difference</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def symmetric_difference(self, other):
    ## N.B. keys() has no symmetric_difference() so convert to full set first
    keys = set(self._index.keys()).symmetric_difference(other._index.keys())
    return self.__class__(conditionalyield(keys,self._index,other._index))</code></pre>
</details>
</dd>
<dt id="graphydb.IndexedSet.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>self, *others)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def union(self, *others):
    return functools.reduce(lambda x,y:x|y,others, self) </code></pre>
</details>
</dd>
<dt id="graphydb.IndexedSet.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, *iterables)</span>
</code></dt>
<dd>
<div class="desc"><p>Uodate the existing items with the items in <code>*iterables</code>.
Returns reference.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, *iterables):
    &#39;&#39;&#39;
    Uodate the existing items with the items in `*iterables`.
    Returns reference.
    &#39;&#39;&#39;
    _add = self.add
    for iterable in iterables:
        for value in iterable:
            _add(value)
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="graphydb.NSet"><code class="flex name class">
<span>class <span class="ident">NSet</span></span>
<span>(</span><span>iterable=[])</span>
</code></dt>
<dd>
<div class="desc"><p>A set holding nodes with some agregate functionality.</p>
<p>Takes an interable of objects with a <code>__uid__()</code> method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NSet(GraphyDBItemSet):
    &#39;&#39;&#39;
    A set holding nodes with some agregate functionality.
    &#39;&#39;&#39;    
    
    def inE(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Fetch incoming edges to all the nodes in the set.
        &#39;&#39;&#39;
        out = ESet()
        args[&#39;WHERE&#39;] = ensurelist(WHERE)
        for v in self:
            out.update(v.inE(**copy.deepcopy(args)))
        return out
    
    def outE(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Fetch outgoing edges to all the nodes in the set.
        &#39;&#39;&#39;
        out = ESet()
        args[&#39;WHERE&#39;] = ensurelist(WHERE)
        for v in self:
            out.update(v.outE(**copy.deepcopy(args)))
        return out
    
    def bothE(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Fetch both incoming and outgoing edges to all the nodes in the set.
        &#39;&#39;&#39;
        out = ESet()
        args[&#39;WHERE&#39;] = ensurelist(WHERE)
        for v in self:
            out.update(v.bothE(**copy.deepcopy(args)))
        return out
    
    def inN(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Fetch nodes on an incomming edge to the nodes in the set. 
        This may include nodes in the set itself.
        &#39;&#39;&#39;
        out = NSet()
        args[&#39;WHERE&#39;] = ensurelist(WHERE)
        for v in self:
            out.update(v.inN(**copy.deepcopy(args)))
        return out
    
    def outN(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Fetch nodes on outgoing edges to the nodes in the set.
        This may include nodes in the set itself.
        &#39;&#39;&#39;
        out = NSet()
        args[&#39;WHERE&#39;] = ensurelist(WHERE)
        for v in self:
            out.update(v.outN(**copy.deepcopy(args)))
        return out
    
    def bothN(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Fetch nodes attached to the nodes in the set.
        This may include nodes in the set itself.
        &#39;&#39;&#39;
        out = NSet()
        args[&#39;WHERE&#39;] = ensurelist(WHERE)
        for v in self:
            out.update(v.bothN(**copy.deepcopy(args)))
        return out    
    
    def delete(self, disconnect=False, batch=None, setchange=True):
        &#39;&#39;&#39;
        Delete the items from the *database*.
        N.B. don&#39;t confuse with remove() and discard() which work only on the set!
        &#39;&#39;&#39;
        if setchange and batch is None:
            ## since we&#39;re deleting in a group this should be batched
            batch = generateUUID()
            
        for item in self:
            item.delete(disconnect=disconnect, batch=batch, setchange=setchange)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="graphydb.GraphyDBItemSet" href="#graphydb.GraphyDBItemSet">GraphyDBItemSet</a></li>
<li><a title="graphydb.IndexedSet" href="#graphydb.IndexedSet">IndexedSet</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="graphydb.NSet.bothE"><code class="name flex">
<span>def <span class="ident">bothE</span></span>(<span>self, WHERE=None, **args)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch both incoming and outgoing edges to all the nodes in the set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bothE(self, WHERE=None, **args):
    &#39;&#39;&#39;
    Fetch both incoming and outgoing edges to all the nodes in the set.
    &#39;&#39;&#39;
    out = ESet()
    args[&#39;WHERE&#39;] = ensurelist(WHERE)
    for v in self:
        out.update(v.bothE(**copy.deepcopy(args)))
    return out</code></pre>
</details>
</dd>
<dt id="graphydb.NSet.bothN"><code class="name flex">
<span>def <span class="ident">bothN</span></span>(<span>self, WHERE=None, **args)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch nodes attached to the nodes in the set.
This may include nodes in the set itself.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bothN(self, WHERE=None, **args):
    &#39;&#39;&#39;
    Fetch nodes attached to the nodes in the set.
    This may include nodes in the set itself.
    &#39;&#39;&#39;
    out = NSet()
    args[&#39;WHERE&#39;] = ensurelist(WHERE)
    for v in self:
        out.update(v.bothN(**copy.deepcopy(args)))
    return out    </code></pre>
</details>
</dd>
<dt id="graphydb.NSet.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, disconnect=False, batch=None, setchange=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete the items from the <em>database</em>.
N.B. don't confuse with remove() and discard() which work only on the set!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, disconnect=False, batch=None, setchange=True):
    &#39;&#39;&#39;
    Delete the items from the *database*.
    N.B. don&#39;t confuse with remove() and discard() which work only on the set!
    &#39;&#39;&#39;
    if setchange and batch is None:
        ## since we&#39;re deleting in a group this should be batched
        batch = generateUUID()
        
    for item in self:
        item.delete(disconnect=disconnect, batch=batch, setchange=setchange)</code></pre>
</details>
</dd>
<dt id="graphydb.NSet.inE"><code class="name flex">
<span>def <span class="ident">inE</span></span>(<span>self, WHERE=None, **args)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch incoming edges to all the nodes in the set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inE(self, WHERE=None, **args):
    &#39;&#39;&#39;
    Fetch incoming edges to all the nodes in the set.
    &#39;&#39;&#39;
    out = ESet()
    args[&#39;WHERE&#39;] = ensurelist(WHERE)
    for v in self:
        out.update(v.inE(**copy.deepcopy(args)))
    return out</code></pre>
</details>
</dd>
<dt id="graphydb.NSet.inN"><code class="name flex">
<span>def <span class="ident">inN</span></span>(<span>self, WHERE=None, **args)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch nodes on an incomming edge to the nodes in the set.
This may include nodes in the set itself.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inN(self, WHERE=None, **args):
    &#39;&#39;&#39;
    Fetch nodes on an incomming edge to the nodes in the set. 
    This may include nodes in the set itself.
    &#39;&#39;&#39;
    out = NSet()
    args[&#39;WHERE&#39;] = ensurelist(WHERE)
    for v in self:
        out.update(v.inN(**copy.deepcopy(args)))
    return out</code></pre>
</details>
</dd>
<dt id="graphydb.NSet.outE"><code class="name flex">
<span>def <span class="ident">outE</span></span>(<span>self, WHERE=None, **args)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch outgoing edges to all the nodes in the set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def outE(self, WHERE=None, **args):
    &#39;&#39;&#39;
    Fetch outgoing edges to all the nodes in the set.
    &#39;&#39;&#39;
    out = ESet()
    args[&#39;WHERE&#39;] = ensurelist(WHERE)
    for v in self:
        out.update(v.outE(**copy.deepcopy(args)))
    return out</code></pre>
</details>
</dd>
<dt id="graphydb.NSet.outN"><code class="name flex">
<span>def <span class="ident">outN</span></span>(<span>self, WHERE=None, **args)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch nodes on outgoing edges to the nodes in the set.
This may include nodes in the set itself.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def outN(self, WHERE=None, **args):
    &#39;&#39;&#39;
    Fetch nodes on outgoing edges to the nodes in the set.
    This may include nodes in the set itself.
    &#39;&#39;&#39;
    out = NSet()
    args[&#39;WHERE&#39;] = ensurelist(WHERE)
    for v in self:
        out.update(v.outN(**copy.deepcopy(args)))
    return out</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="graphydb.GraphyDBItemSet" href="#graphydb.GraphyDBItemSet">GraphyDBItemSet</a></b></code>:
<ul class="hlist">
<li><code><a title="graphydb.GraphyDBItemSet.add" href="#graphydb.IndexedSet.add">add</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.append" href="#graphydb.IndexedSet.append">append</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.clear" href="#graphydb.IndexedSet.clear">clear</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.copy" href="#graphydb.IndexedSet.copy">copy</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.deletefts" href="#graphydb.GraphyDBItemSet.deletefts">deletefts</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.discard" href="#graphydb.IndexedSet.discard">discard</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.filter" href="#graphydb.GraphyDBItemSet.filter">filter</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.filter_fnmatch" href="#graphydb.GraphyDBItemSet.filter_fnmatch">filter_fnmatch</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.get" href="#graphydb.GraphyDBItemSet.get">get</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.getm" href="#graphydb.GraphyDBItemSet.getm">getm</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.one" href="#graphydb.GraphyDBItemSet.one">one</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.pop" href="#graphydb.IndexedSet.pop">pop</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.remove" href="#graphydb.IndexedSet.remove">remove</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.reverse" href="#graphydb.IndexedSet.reverse">reverse</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.save" href="#graphydb.GraphyDBItemSet.save">save</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.set" href="#graphydb.GraphyDBItemSet.set">set</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.setGraph" href="#graphydb.GraphyDBItemSet.setGraph">setGraph</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.sort" href="#graphydb.IndexedSet.sort">sort</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.update" href="#graphydb.IndexedSet.update">update</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="graphydb.Node"><code class="flex name class">
<span>class <span class="ident">Node</span></span>
<span>(</span><span>data, graph=None, changed=True)</span>
</code></dt>
<dd>
<div class="desc"><p>A Node object
can contain abitrary key value pairs as long as they are JSONifiable </p>
<p>GraphyDBItem shoudn't be instantiated directly. Use <code><a title="graphydb.Node" href="#graphydb.Node">Node</a></code> or <code><a title="graphydb.Edge" href="#graphydb.Edge">Edge</a></code> instead.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Node(GraphyDBItem):
    &#39;&#39;&#39;
    A Node object
    can contain abitrary key value pairs as long as they are JSONifiable 
    &#39;&#39;&#39;
    
    _table = &#39;nodes&#39;
    _ftstable = &#39;nodefts&#39;
    
    def __init__(self, data, graph=None, changed=True):
        if data.setdefault(&#39;kind&#39;, None) is None:
            raise GraphyDBException(&#34;Must supply Node kind&#34;)        
        super().__init__(data, graph=graph, changed=changed)
        
    def save(self, force=False, batch=None, setchange=True):
        &#39;&#39;&#39;
        Save the data to the database. Any keys that begin with &#34;_&#34; will *not* be saved.
        
        - `force`: if `True` will save regardless if item marked as changed.
        &#39;&#39;&#39;
        ## ignore if unforced and not changed
        if not force and not self.changed:
            return self        
        
        cursor = self.graph.cursor()
        data = cleandata(self.data)
                
        if setchange:
            originalitem = self.original()
        
        cursor.execute(&#34;INSERT OR REPLACE INTO nodes(uid, kind, ctime, mtime, data) VALUES(?,?,?,?,?)&#34;, 
                       (self[&#39;uid&#39;], self[&#39;kind&#39;], self[&#39;ctime&#39;], self[&#39;mtime&#39;], json.dumps(data)) )
        
        if setchange:
            self.graph.addchange(old=originalitem, new=self, batch=batch)                        
        
        self.setChanged(False)
        return self
        
        
    def inE(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Fetch incomming edges i.e. &#34;&lt;[e]-&#34; with &#34;e.enduid = self.uid&#34; 
        (see `Graph.fetch` for details)
        &#39;&#39;&#39;
        args[&#39;CHAIN&#39;] = &#39;&lt;(e)-&#39;
        args[&#39;WHERE&#39;] = ensurelist(WHERE)
        args[&#39;WHERE&#39;].insert(0,&#39;e.enduid = :node_uid&#39;)
        args[&#39;node_uid&#39;] = self[&#39;uid&#39;]
            
        return self.graph.fetch(**args)
        
    def outE(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Fetch outgoing edges, i.e. &#34;-[e]&gt;&#34; with &#34;e.startuid = self.uid&#34; 
        (see `Graph.fetch` for details)
        &#39;&#39;&#39;
        args[&#39;CHAIN&#39;] = &#39;-(e)&gt;&#39;
        args[&#39;WHERE&#39;] = ensurelist(WHERE)
        args[&#39;WHERE&#39;].insert(0,&#39;e.startuid = :node_uid&#39;)
        args[&#39;node_uid&#39;] = self[&#39;uid&#39;]
            
        return self.graph.fetch(**args)   
    
    def bothE(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Get edges both incomming and outgoing 
        (see `Graph.fetch` for details)
        &#39;&#39;&#39;
        args[&#39;WHERE&#39;] = ensurelist(WHERE)
        ## A deep copy is necessary as inE and outE 
        ## modify the dict or lists withing the dict
        if args.get(&#39;COUNT&#39;, False):
            ## COUNT=True will fail as it doesn&#39;t check uniqueness across   
            ## in and out sets fetch actual items and count in python
            args[&#39;COUNT&#39;] = False
            ine = self.inE(**copy.deepcopy(args))
            oute = self.outE(**copy.deepcopy(args))            
            return len(ine|oute)
        else:
            ine = self.inE(**copy.deepcopy(args))
            oute = self.outE(**copy.deepcopy(args))            
            ## union of sets
            return ine | oute 
    
    def inN(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Fetch nodes on an incomming edge i.e. &#34;&lt;(e)- [n]&#34; with &#34;e.enduid = self.uid&#34; 
        (see `Graph.fetch` for details)
        &#39;&#39;&#39;
        args[&#39;CHAIN&#39;] = &#39;&lt;(e)- [n]&#39;
        args[&#39;WHERE&#39;] = ensurelist(WHERE)     
        args[&#39;WHERE&#39;].insert(0,&#39;e.enduid = :node_uid&#39;)
        args[&#39;node_uid&#39;] = self[&#39;uid&#39;]
            
        return self.graph.fetch(**args) 
    
    def outN(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Fetch nodes on an outgoing edge &#34;-(e)&gt; [n]&#34; with &#34;e.startuid = self.uid&#34; 
        (see `Graph.fetch` for details)
        &#39;&#39;&#39;
        args[&#39;CHAIN&#39;] = &#39;-(e)&gt; [n]&#39;
        args[&#39;WHERE&#39;] = ensurelist(WHERE)        
        args[&#39;WHERE&#39;].insert(0,&#39;e.startuid = :node_uid&#39;)
        args[&#39;node_uid&#39;] = self[&#39;uid&#39;]
            
        return self.graph.fetch(**args) 
    
    def bothN(self, WHERE=None, **args):
        &#39;&#39;&#39;
        Fetch nodes connected by edge 
        (see `Graph.fetch` for details)
        &#39;&#39;&#39;
        args[&#39;WHERE&#39;] = ensurelist(WHERE)
        ## A deep copy is necessary as inE and outE 
        ## modify the dict or lists withing the dict 
        if args.get(&#39;COUNT&#39;, False):
            ## COUNT=True will fail as it doesn&#39;t check uniqueness across    
            ## in and out sets fetch actual items and count in python
            args[&#39;COUNT&#39;] = False
            inn = self.inN(**copy.deepcopy(args))
            outn = self.outN(**copy.deepcopy(args))              
            return len(inn|outn)
        else:
            inn = self.inN(**copy.deepcopy(args))
            outn = self.outN(**copy.deepcopy(args))            
            ## union of sets
            return inn | outn         
            
    def delete(self, disconnect=False, batch=None, setchange=True):
        &#39;&#39;&#39;
        Delete this node from the database.
        
        `disconnect`: If `True`, silently delete any connected edges, else raise an Exception
        if the node is connected and deleting it would leave the graph inconsistent.
        &#39;&#39;&#39;
        cursor = self.graph.cursor()
        if self.outE(COUNT=True)+self.inE(COUNT=True) &gt; 0:
            if disconnect:
                if setchange and batch is None:
                    ## if no batch set, set one now to group all the edges and node in a single change set
                    batch = generateUUID()                 
                for edge in self.bothE():                
                    edge.delete(batch=batch, setchange=setchange)                           
            else:
                raise GraphyDBException(&#34;Node still connected. Delete Edges First&#34;)
        
        cursor.execute(&#39;DELETE FROM nodes WHERE uid = ?&#39;, (self[&#39;uid&#39;],))
        
        if setchange:  
            self.graph.addchange(old=self, batch=batch)
        
        
        self.deletefts()
        self[&#39;mtime&#39;] = time.time()
        self.setChanged(True)
        return self
        
    def __repr__(self):
        return &#39;({uid}:{kind})&#39;.format(**self.data)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="graphydb.GraphyDBItem" href="#graphydb.GraphyDBItem">GraphyDBItem</a></li>
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="graphydb.Node.bothE"><code class="name flex">
<span>def <span class="ident">bothE</span></span>(<span>self, WHERE=None, **args)</span>
</code></dt>
<dd>
<div class="desc"><p>Get edges both incomming and outgoing
(see <code><a title="graphydb.Graph.fetch" href="#graphydb.Graph.fetch">Graph.fetch()</a></code> for details)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bothE(self, WHERE=None, **args):
    &#39;&#39;&#39;
    Get edges both incomming and outgoing 
    (see `Graph.fetch` for details)
    &#39;&#39;&#39;
    args[&#39;WHERE&#39;] = ensurelist(WHERE)
    ## A deep copy is necessary as inE and outE 
    ## modify the dict or lists withing the dict
    if args.get(&#39;COUNT&#39;, False):
        ## COUNT=True will fail as it doesn&#39;t check uniqueness across   
        ## in and out sets fetch actual items and count in python
        args[&#39;COUNT&#39;] = False
        ine = self.inE(**copy.deepcopy(args))
        oute = self.outE(**copy.deepcopy(args))            
        return len(ine|oute)
    else:
        ine = self.inE(**copy.deepcopy(args))
        oute = self.outE(**copy.deepcopy(args))            
        ## union of sets
        return ine | oute </code></pre>
</details>
</dd>
<dt id="graphydb.Node.bothN"><code class="name flex">
<span>def <span class="ident">bothN</span></span>(<span>self, WHERE=None, **args)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch nodes connected by edge
(see <code><a title="graphydb.Graph.fetch" href="#graphydb.Graph.fetch">Graph.fetch()</a></code> for details)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bothN(self, WHERE=None, **args):
    &#39;&#39;&#39;
    Fetch nodes connected by edge 
    (see `Graph.fetch` for details)
    &#39;&#39;&#39;
    args[&#39;WHERE&#39;] = ensurelist(WHERE)
    ## A deep copy is necessary as inE and outE 
    ## modify the dict or lists withing the dict 
    if args.get(&#39;COUNT&#39;, False):
        ## COUNT=True will fail as it doesn&#39;t check uniqueness across    
        ## in and out sets fetch actual items and count in python
        args[&#39;COUNT&#39;] = False
        inn = self.inN(**copy.deepcopy(args))
        outn = self.outN(**copy.deepcopy(args))              
        return len(inn|outn)
    else:
        inn = self.inN(**copy.deepcopy(args))
        outn = self.outN(**copy.deepcopy(args))            
        ## union of sets
        return inn | outn         </code></pre>
</details>
</dd>
<dt id="graphydb.Node.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, disconnect=False, batch=None, setchange=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete this node from the database.</p>
<p><code>disconnect</code>: If <code>True</code>, silently delete any connected edges, else raise an Exception
if the node is connected and deleting it would leave the graph inconsistent.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, disconnect=False, batch=None, setchange=True):
    &#39;&#39;&#39;
    Delete this node from the database.
    
    `disconnect`: If `True`, silently delete any connected edges, else raise an Exception
    if the node is connected and deleting it would leave the graph inconsistent.
    &#39;&#39;&#39;
    cursor = self.graph.cursor()
    if self.outE(COUNT=True)+self.inE(COUNT=True) &gt; 0:
        if disconnect:
            if setchange and batch is None:
                ## if no batch set, set one now to group all the edges and node in a single change set
                batch = generateUUID()                 
            for edge in self.bothE():                
                edge.delete(batch=batch, setchange=setchange)                           
        else:
            raise GraphyDBException(&#34;Node still connected. Delete Edges First&#34;)
    
    cursor.execute(&#39;DELETE FROM nodes WHERE uid = ?&#39;, (self[&#39;uid&#39;],))
    
    if setchange:  
        self.graph.addchange(old=self, batch=batch)
    
    
    self.deletefts()
    self[&#39;mtime&#39;] = time.time()
    self.setChanged(True)
    return self</code></pre>
</details>
</dd>
<dt id="graphydb.Node.inE"><code class="name flex">
<span>def <span class="ident">inE</span></span>(<span>self, WHERE=None, **args)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch incomming edges i.e. "&lt;[e]-" with "e.enduid = self.uid"
(see <code><a title="graphydb.Graph.fetch" href="#graphydb.Graph.fetch">Graph.fetch()</a></code> for details)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inE(self, WHERE=None, **args):
    &#39;&#39;&#39;
    Fetch incomming edges i.e. &#34;&lt;[e]-&#34; with &#34;e.enduid = self.uid&#34; 
    (see `Graph.fetch` for details)
    &#39;&#39;&#39;
    args[&#39;CHAIN&#39;] = &#39;&lt;(e)-&#39;
    args[&#39;WHERE&#39;] = ensurelist(WHERE)
    args[&#39;WHERE&#39;].insert(0,&#39;e.enduid = :node_uid&#39;)
    args[&#39;node_uid&#39;] = self[&#39;uid&#39;]
        
    return self.graph.fetch(**args)</code></pre>
</details>
</dd>
<dt id="graphydb.Node.inN"><code class="name flex">
<span>def <span class="ident">inN</span></span>(<span>self, WHERE=None, **args)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch nodes on an incomming edge i.e. "&lt;(e)- [n]" with "e.enduid = self.uid"
(see <code><a title="graphydb.Graph.fetch" href="#graphydb.Graph.fetch">Graph.fetch()</a></code> for details)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inN(self, WHERE=None, **args):
    &#39;&#39;&#39;
    Fetch nodes on an incomming edge i.e. &#34;&lt;(e)- [n]&#34; with &#34;e.enduid = self.uid&#34; 
    (see `Graph.fetch` for details)
    &#39;&#39;&#39;
    args[&#39;CHAIN&#39;] = &#39;&lt;(e)- [n]&#39;
    args[&#39;WHERE&#39;] = ensurelist(WHERE)     
    args[&#39;WHERE&#39;].insert(0,&#39;e.enduid = :node_uid&#39;)
    args[&#39;node_uid&#39;] = self[&#39;uid&#39;]
        
    return self.graph.fetch(**args) </code></pre>
</details>
</dd>
<dt id="graphydb.Node.outE"><code class="name flex">
<span>def <span class="ident">outE</span></span>(<span>self, WHERE=None, **args)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch outgoing edges, i.e. "-[e]&gt;" with "e.startuid = self.uid"
(see <code><a title="graphydb.Graph.fetch" href="#graphydb.Graph.fetch">Graph.fetch()</a></code> for details)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def outE(self, WHERE=None, **args):
    &#39;&#39;&#39;
    Fetch outgoing edges, i.e. &#34;-[e]&gt;&#34; with &#34;e.startuid = self.uid&#34; 
    (see `Graph.fetch` for details)
    &#39;&#39;&#39;
    args[&#39;CHAIN&#39;] = &#39;-(e)&gt;&#39;
    args[&#39;WHERE&#39;] = ensurelist(WHERE)
    args[&#39;WHERE&#39;].insert(0,&#39;e.startuid = :node_uid&#39;)
    args[&#39;node_uid&#39;] = self[&#39;uid&#39;]
        
    return self.graph.fetch(**args)   </code></pre>
</details>
</dd>
<dt id="graphydb.Node.outN"><code class="name flex">
<span>def <span class="ident">outN</span></span>(<span>self, WHERE=None, **args)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch nodes on an outgoing edge "-(e)&gt; [n]" with "e.startuid = self.uid"
(see <code><a title="graphydb.Graph.fetch" href="#graphydb.Graph.fetch">Graph.fetch()</a></code> for details)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def outN(self, WHERE=None, **args):
    &#39;&#39;&#39;
    Fetch nodes on an outgoing edge &#34;-(e)&gt; [n]&#34; with &#34;e.startuid = self.uid&#34; 
    (see `Graph.fetch` for details)
    &#39;&#39;&#39;
    args[&#39;CHAIN&#39;] = &#39;-(e)&gt; [n]&#39;
    args[&#39;WHERE&#39;] = ensurelist(WHERE)        
    args[&#39;WHERE&#39;].insert(0,&#39;e.startuid = :node_uid&#39;)
    args[&#39;node_uid&#39;] = self[&#39;uid&#39;]
        
    return self.graph.fetch(**args) </code></pre>
</details>
</dd>
<dt id="graphydb.Node.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, force=False, batch=None, setchange=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the data to the database. Any keys that begin with "_" will <em>not</em> be saved.</p>
<ul>
<li><code>force</code>: if <code>True</code> will save regardless if item marked as changed.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, force=False, batch=None, setchange=True):
    &#39;&#39;&#39;
    Save the data to the database. Any keys that begin with &#34;_&#34; will *not* be saved.
    
    - `force`: if `True` will save regardless if item marked as changed.
    &#39;&#39;&#39;
    ## ignore if unforced and not changed
    if not force and not self.changed:
        return self        
    
    cursor = self.graph.cursor()
    data = cleandata(self.data)
            
    if setchange:
        originalitem = self.original()
    
    cursor.execute(&#34;INSERT OR REPLACE INTO nodes(uid, kind, ctime, mtime, data) VALUES(?,?,?,?,?)&#34;, 
                   (self[&#39;uid&#39;], self[&#39;kind&#39;], self[&#39;ctime&#39;], self[&#39;mtime&#39;], json.dumps(data)) )
    
    if setchange:
        self.graph.addchange(old=originalitem, new=self, batch=batch)                        
    
    self.setChanged(False)
    return self</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="graphydb.GraphyDBItem" href="#graphydb.GraphyDBItem">GraphyDBItem</a></b></code>:
<ul class="hlist">
<li><code><a title="graphydb.GraphyDBItem.changed" href="#graphydb.GraphyDBItem.changed">changed</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.data" href="#graphydb.GraphyDBItem.data">data</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.deletefts" href="#graphydb.GraphyDBItem.deletefts">deletefts</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.exists" href="#graphydb.GraphyDBItem.exists">exists</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.graph" href="#graphydb.GraphyDBItem.graph">graph</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.original" href="#graphydb.GraphyDBItem.original">original</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.renew" href="#graphydb.GraphyDBItem.renew">renew</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.set" href="#graphydb.GraphyDBItem.set">set</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.setChanged" href="#graphydb.GraphyDBItem.setChanged">setChanged</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.setGraph" href="#graphydb.GraphyDBItem.setGraph">setGraph</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.updatefts" href="#graphydb.GraphyDBItem.updatefts">updatefts</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#quick-start">Quick start</a></li>
<li><a href="#sqlite-structure">SQLite structure</a><ul>
<li><a href="#nodes">Nodes</a></li>
<li><a href="#edges">Edges</a></li>
<li><a href="#additional-tables">Additional tables</a></li>
</ul>
</li>
<li><a href="#installing">Installing</a><ul>
<li><a href="#dependencies">Dependencies</a></li>
</ul>
</li>
<li><a href="#module-details">Module details</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="graphydb.FETCHKEYWORDS" href="#graphydb.FETCHKEYWORDS">FETCHKEYWORDS</a></code></li>
<li><code><a title="graphydb.RESERVED" href="#graphydb.RESERVED">RESERVED</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="graphydb.cleandata" href="#graphydb.cleandata">cleandata</a></code></li>
<li><code><a title="graphydb.conditionalyield" href="#graphydb.conditionalyield">conditionalyield</a></code></li>
<li><code><a title="graphydb.diff" href="#graphydb.diff">diff</a></code></li>
<li><code><a title="graphydb.ensurelist" href="#graphydb.ensurelist">ensurelist</a></code></li>
<li><code><a title="graphydb.generateUUID" href="#graphydb.generateUUID">generateUUID</a></code></li>
<li><code><a title="graphydb.jsonextract" href="#graphydb.jsonextract">jsonextract</a></code></li>
<li><code><a title="graphydb.patch" href="#graphydb.patch">patch</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="graphydb.ESet" href="#graphydb.ESet">ESet</a></code></h4>
<ul class="">
<li><code><a title="graphydb.ESet.delete" href="#graphydb.ESet.delete">delete</a></code></li>
<li><code><a title="graphydb.ESet.end" href="#graphydb.ESet.end">end</a></code></li>
<li><code><a title="graphydb.ESet.start" href="#graphydb.ESet.start">start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="graphydb.Edge" href="#graphydb.Edge">Edge</a></code></h4>
<ul class="">
<li><code><a title="graphydb.Edge.delete" href="#graphydb.Edge.delete">delete</a></code></li>
<li><code><a title="graphydb.Edge.end" href="#graphydb.Edge.end">end</a></code></li>
<li><code><a title="graphydb.Edge.save" href="#graphydb.Edge.save">save</a></code></li>
<li><code><a title="graphydb.Edge.start" href="#graphydb.Edge.start">start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="graphydb.Graph" href="#graphydb.Graph">Graph</a></code></h4>
<ul class="two-column">
<li><code><a title="graphydb.Graph.Edge" href="#graphydb.Graph.Edge">Edge</a></code></li>
<li><code><a title="graphydb.Graph.Node" href="#graphydb.Graph.Node">Node</a></code></li>
<li><code><a title="graphydb.Graph.addchange" href="#graphydb.Graph.addchange">addchange</a></code></li>
<li><code><a title="graphydb.Graph.cache" href="#graphydb.Graph.cache">cache</a></code></li>
<li><code><a title="graphydb.Graph.cached" href="#graphydb.Graph.cached">cached</a></code></li>
<li><code><a title="graphydb.Graph.clearchanges" href="#graphydb.Graph.clearchanges">clearchanges</a></code></li>
<li><code><a title="graphydb.Graph.countchanges" href="#graphydb.Graph.countchanges">countchanges</a></code></li>
<li><code><a title="graphydb.Graph.cursor" href="#graphydb.Graph.cursor">cursor</a></code></li>
<li><code><a title="graphydb.Graph.deletechange" href="#graphydb.Graph.deletechange">deletechange</a></code></li>
<li><code><a title="graphydb.Graph.exists" href="#graphydb.Graph.exists">exists</a></code></li>
<li><code><a title="graphydb.Graph.fetch" href="#graphydb.Graph.fetch">fetch</a></code></li>
<li><code><a title="graphydb.Graph.getsetting" href="#graphydb.Graph.getsetting">getsetting</a></code></li>
<li><code><a title="graphydb.Graph.getuid" href="#graphydb.Graph.getuid">getuid</a></code></li>
<li><code><a title="graphydb.Graph.lastchanges" href="#graphydb.Graph.lastchanges">lastchanges</a></code></li>
<li><code><a title="graphydb.Graph.reset" href="#graphydb.Graph.reset">reset</a></code></li>
<li><code><a title="graphydb.Graph.resetfts" href="#graphydb.Graph.resetfts">resetfts</a></code></li>
<li><code><a title="graphydb.Graph.savesetting" href="#graphydb.Graph.savesetting">savesetting</a></code></li>
<li><code><a title="graphydb.Graph.stats" href="#graphydb.Graph.stats">stats</a></code></li>
<li><code><a title="graphydb.Graph.undo" href="#graphydb.Graph.undo">undo</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="graphydb.GraphyDBException" href="#graphydb.GraphyDBException">GraphyDBException</a></code></h4>
</li>
<li>
<h4><code><a title="graphydb.GraphyDBItem" href="#graphydb.GraphyDBItem">GraphyDBItem</a></code></h4>
<ul class="two-column">
<li><code><a title="graphydb.GraphyDBItem.changed" href="#graphydb.GraphyDBItem.changed">changed</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.copy" href="#graphydb.GraphyDBItem.copy">copy</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.data" href="#graphydb.GraphyDBItem.data">data</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.deepcopy" href="#graphydb.GraphyDBItem.deepcopy">deepcopy</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.deletefts" href="#graphydb.GraphyDBItem.deletefts">deletefts</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.exists" href="#graphydb.GraphyDBItem.exists">exists</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.fromkeys" href="#graphydb.GraphyDBItem.fromkeys">fromkeys</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.graph" href="#graphydb.GraphyDBItem.graph">graph</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.original" href="#graphydb.GraphyDBItem.original">original</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.renew" href="#graphydb.GraphyDBItem.renew">renew</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.set" href="#graphydb.GraphyDBItem.set">set</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.setChanged" href="#graphydb.GraphyDBItem.setChanged">setChanged</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.setGraph" href="#graphydb.GraphyDBItem.setGraph">setGraph</a></code></li>
<li><code><a title="graphydb.GraphyDBItem.updatefts" href="#graphydb.GraphyDBItem.updatefts">updatefts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="graphydb.GraphyDBItemSet" href="#graphydb.GraphyDBItemSet">GraphyDBItemSet</a></code></h4>
<ul class="two-column">
<li><code><a title="graphydb.GraphyDBItemSet.deletefts" href="#graphydb.GraphyDBItemSet.deletefts">deletefts</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.filter" href="#graphydb.GraphyDBItemSet.filter">filter</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.filter_fnmatch" href="#graphydb.GraphyDBItemSet.filter_fnmatch">filter_fnmatch</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.get" href="#graphydb.GraphyDBItemSet.get">get</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.getm" href="#graphydb.GraphyDBItemSet.getm">getm</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.one" href="#graphydb.GraphyDBItemSet.one">one</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.save" href="#graphydb.GraphyDBItemSet.save">save</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.set" href="#graphydb.GraphyDBItemSet.set">set</a></code></li>
<li><code><a title="graphydb.GraphyDBItemSet.setGraph" href="#graphydb.GraphyDBItemSet.setGraph">setGraph</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="graphydb.IndexedSet" href="#graphydb.IndexedSet">IndexedSet</a></code></h4>
<ul class="">
<li><code><a title="graphydb.IndexedSet.add" href="#graphydb.IndexedSet.add">add</a></code></li>
<li><code><a title="graphydb.IndexedSet.append" href="#graphydb.IndexedSet.append">append</a></code></li>
<li><code><a title="graphydb.IndexedSet.clear" href="#graphydb.IndexedSet.clear">clear</a></code></li>
<li><code><a title="graphydb.IndexedSet.copy" href="#graphydb.IndexedSet.copy">copy</a></code></li>
<li><code><a title="graphydb.IndexedSet.difference" href="#graphydb.IndexedSet.difference">difference</a></code></li>
<li><code><a title="graphydb.IndexedSet.discard" href="#graphydb.IndexedSet.discard">discard</a></code></li>
<li><code><a title="graphydb.IndexedSet.intersection" href="#graphydb.IndexedSet.intersection">intersection</a></code></li>
<li><code><a title="graphydb.IndexedSet.pop" href="#graphydb.IndexedSet.pop">pop</a></code></li>
<li><code><a title="graphydb.IndexedSet.remove" href="#graphydb.IndexedSet.remove">remove</a></code></li>
<li><code><a title="graphydb.IndexedSet.reverse" href="#graphydb.IndexedSet.reverse">reverse</a></code></li>
<li><code><a title="graphydb.IndexedSet.sort" href="#graphydb.IndexedSet.sort">sort</a></code></li>
<li><code><a title="graphydb.IndexedSet.symmetric_difference" href="#graphydb.IndexedSet.symmetric_difference">symmetric_difference</a></code></li>
<li><code><a title="graphydb.IndexedSet.union" href="#graphydb.IndexedSet.union">union</a></code></li>
<li><code><a title="graphydb.IndexedSet.update" href="#graphydb.IndexedSet.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="graphydb.NSet" href="#graphydb.NSet">NSet</a></code></h4>
<ul class="two-column">
<li><code><a title="graphydb.NSet.bothE" href="#graphydb.NSet.bothE">bothE</a></code></li>
<li><code><a title="graphydb.NSet.bothN" href="#graphydb.NSet.bothN">bothN</a></code></li>
<li><code><a title="graphydb.NSet.delete" href="#graphydb.NSet.delete">delete</a></code></li>
<li><code><a title="graphydb.NSet.inE" href="#graphydb.NSet.inE">inE</a></code></li>
<li><code><a title="graphydb.NSet.inN" href="#graphydb.NSet.inN">inN</a></code></li>
<li><code><a title="graphydb.NSet.outE" href="#graphydb.NSet.outE">outE</a></code></li>
<li><code><a title="graphydb.NSet.outN" href="#graphydb.NSet.outN">outN</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="graphydb.Node" href="#graphydb.Node">Node</a></code></h4>
<ul class="two-column">
<li><code><a title="graphydb.Node.bothE" href="#graphydb.Node.bothE">bothE</a></code></li>
<li><code><a title="graphydb.Node.bothN" href="#graphydb.Node.bothN">bothN</a></code></li>
<li><code><a title="graphydb.Node.delete" href="#graphydb.Node.delete">delete</a></code></li>
<li><code><a title="graphydb.Node.inE" href="#graphydb.Node.inE">inE</a></code></li>
<li><code><a title="graphydb.Node.inN" href="#graphydb.Node.inN">inN</a></code></li>
<li><code><a title="graphydb.Node.outE" href="#graphydb.Node.outE">outE</a></code></li>
<li><code><a title="graphydb.Node.outN" href="#graphydb.Node.outN">outN</a></code></li>
<li><code><a title="graphydb.Node.save" href="#graphydb.Node.save">save</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>